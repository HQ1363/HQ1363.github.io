---
title: 聊聊持续集成   
date: 2021-08-01 00:02:15   
tags: CI   
categories: CI   
excerpt: 持续集成，简称`CI`，也不是一个新概念了；早在极限编程(XP)中，便作为12种实践之一被提出。最近三四年，随着`DevOps`概念逐渐被重视，`CI/CD`也成了市面上津津乐道的一个东西；然而也就是这么一个东西，即使每个公司都有着自己的实践方案，也仍然被其内部员工不停吐槽，这其中有很多原因，本文将会提到一部分；同时本文也将从多个角度，反复推敲`CI`，欢迎大佬们驻足留言，谢谢～
---

> 持续集成，简称`CI`，也不是一个新概念了；早在极限编程(XP)中，便作为12种实践之一被提出。最近三四年，随着`DevOps`概念逐渐被重视，`CI/CD`也成了市面上津津乐道的一个东西；然而也就是这么一个东西，即使每个公司都有着自己的实践方案，也仍然被其内部员工不停吐槽，这其中有很多原因，本文将会提到一部分；同时本文也将从多个角度，反复推敲`CI`，欢迎大佬们驻足留言，谢谢～

## 暖场热身
**<span style="color: blue">Q1</span>：你知道什么是`CI`吗？**   
_我相信很多人都听过CI，当我问出这个问题的时候，估计有人就会说了，这谁不知道啊，不就是`Continuous integration`嘛，整的好像谁不知道似的；紧接着，我要问了，那什么是`Continuous integration`呢。曾经我问过好几个开发朋友，他们也表示只知道字面意思，平时的工作"好像"也和CI没什么关系，应该指的就是打包、构建吧！！！_

**<span style="color: blue">Q2</span>: 你知道为啥需要`CI`吗？**   
_可能有的开发会说，我不需要，这东西浪费我开发时间，我只想专心写代码，现在整的一堆麻烦事，严重影响我的开发效率，真的是搞事情！！！_

**<span style="color: blue">Q3</span>: 你知道作为一名`Dev/Qa`，需要关注`CI`的哪些东西呢？**   
_只知道死干活的人，可能根本就不会去思考这类问题；说来也奇怪，往往是那些喜欢偷懒的人，懂得变通，可以想尽一切办法去偷懒。_

**<span style="color: blue">Q4</span>: 你知道大厂的CI都是怎么玩的吗？**   
_诚然，即便在业界已经有众多开源解决方案的今天，当结合到每家公司的不同场景下，往往会呈现出不同的效应；每家公司的发展阶段和侧重点是不一样的，其所需要落地的目标也是不尽相同的；特别是在一家快速发展的公司，你会发现其`CI`流程也是在逐渐变化，不停发展演进的。这也就意味着，在设计`CI`的时候，你需要充分考虑后期的可扩展性、可维护性、以及健壮性；以避免后期出现大规模的改动。_

**<span style="color: blue">Q5</span>: 倘若让你去设计CI流程，你会如何设计？**   
_一个好的CI流程，将会让开发团队极大受益，不仅能尽早地发现问题，还能维持高效、稳定、安全的业务迭代速度。_

---

在介绍持续集成之前，我想先介绍下传统的开发过程下的坑：

- BUG总是很晚才被发现，并且难以修复
- 研发交付质量无法得到保障
- 变更频繁，研发效率低下
- 重复性劳动，无效等待过多，用户满意度低

如果你经历过或正在经历传统开发模式的伤与痛，你是否用过/想过：

- 什么时候可以不用再为开发/测试环境而苦恼
- 什么时候可以不用再麻烦运维帮忙调试环境
- 什么时候可以不用手动测试，自动帮我测试
- 什么时候可以只专注于代码的开发

> 既然如此，我们话不多说，一起来了解一下`CI`吧；当然了，如果是大佬，我这就班门弄斧了，还望大佬们批评指正。

## 基础概念
- 持续：意为长期、频繁不断地
- 集成：将一些孤立的事物或者元素通过某种方式联系在一起，从而构成一个有机整体的过程

### 定义
* 是一种通过在应用开发阶段引入自动化来频繁向客户交付应用的方法
* 是一种软件开发实践，项目成员能够频繁地进行集成，并通过自动化方式来尽快发现问题

### 特点
- 需要有代码托管工具支持，如：[github](https://github.com)、[gitee](https://gitee.com)
- 需要有专门的集成服务器来执行集成构建，如：[Jenkins](https://www.jenkins.io/zh/)、[CircleCI](https://circleci.com/)、[TravisCI](https://travis-ci.com/)
- 它是一个自动化的周期性集成测试过程，从检出代码、编译构建、运行测试、结果记录、测试统计等都是自动完成的，无需人工干预

### 作用
- 可以提高软件开发和交付过程的透明度和洞察力
- 有效减少重复过程，节省时间、成本和工作量，完全自动化，利于尽早发现问题
- 可以帮助开发人员更加频繁地（有时甚至每天）将代码变更合并到共享分支或“主干”中

### 目的
- 就是让产品可以快速迭代，同时还能保持高质量；即：高效率、高质量、高产出。

以上仅代表个人对`CI`的理解，关于基础概念这一块，可详细读一读[「Martin Fowler的持续集成」](https://www.cnblogs.com/davenkin/archive/2012/02/25/continuous-integration-from-martin-fowler.html)

---

## 组成模块

### 仓库管理
> 一个好的仓库管理方式，在很多程度上，决定了研发之间的沟通协作方式；虽然是老生常谈的话题，但这个环节确实有必要拿出来捋一捋。到底是选择`mono repo`还是`multi repo`呢？我们来看看这其中的优缺点：

- `mono repo`   
也就是常说的<strong>单体仓库</strong>，它是将所有的服务，全部放到一个代码库，包含了每个业务的服务代码和公共的`Lib`库、`Tools`集合；既然代码都放到一起，也就很好管理了，带来的好处也不少，比如：
  * 易于开发者测试
  * 易于标准化代码
  * 易于开展Code Review
  * 易于共享公共组件，避免重复造轮子
  * 易于重构
- `multi repo`   
和单体仓库相反，为<strong>多仓库</strong>方式；每个服务代码单独成库，各自为营，彼此之间，井水不犯河水，做了很好的隔离。也就说多仓库具备如下特点：
  * 服务之间职责划分清晰
  * 易于扩展，服务之间的解耦
  * 限制clone范围，避免代码库完全泄漏

可以发现，`mono repo`的优点恰恰是`multi repo`的缺点，两者之间是互斥的关系；中小型的企业，一般用的是单体仓库，大型企业往往是多仓库；如果单论优点的个数，貌似mono repo确实更好一些，但其实也有一些大公司，用的是单体仓库，如：`Google`、`Facebook`、`Salesforce`.

### 分支管理
> 但凡提交过代码，就一定会涉及到分支，至少也会有一个`master`默认分支；如果你是一个优秀的<strong style="color: orange">Coder</strong>，在分支使用上，必然有一定的讲究，比如<u>分支的命名、分支的存活周期</u>上。业内有很多的分支管理方法，包括著名的<strong style="color: blue">GitFlow</strong>、<strong style="color: blue">TBD</strong>以及从他们衍生出来的版本。

![git_flow.png](git_flow.png)
- `feature`分支：具体要开发的功能的分支，完成后合并到develop
- `develop`分支：开发的主分支，feature和release分支会基于此分支
- `release`分支：用于发布新版本的分支，完成后合并到develop和master
- `hotfix`分支：用于紧急修复已发布的产品问题的分支，完成后合并到develop和master
- `master`分支：与产品环境代码保持一致的分支，也就是每次发布完成之后发布的功能分支就要合并于此，以保持master更新

<strong>持续集成</strong>往往会基于分支做逻辑，不同的分支往往代表了研发的不同阶段；<u>合并分支的过程，其实就是一次代码集成的过程</u>；一个好的分支策略，不仅能使研发养成良好的开发习惯，还能加大持续集成发现问题的可能性。

### 代码质量
> 当然了，持续集成，最关心的当属<strong style="color: orange">代码质量</strong>这一块了；而在代码质量评估这个环节，可以做的事情很多，但却很难发现所有的问题，只能说尽可能地、今快递去发现问题。<span style="color: blue">Martin Fowler</span>曾说过，"<u>持续集成并不能消除Bug，而是让它们非常容易发现和改正</u>"。

- `编译构建`   
这个是肯定的，提交的代码如果编译都没法完成，下面的几步，根本没必要进行。有些公司，可能还会包含打包构建出产物的环节，但这属于持续交付，不应纳入持续集成环节。

- `代码评审`   
很多时候，我们会「因时间不够，需要急着上线」抑或是「代码太多，看不过来，也不想看」等原因不去`Code Review`。然而实际上，编写可维护代码的秘诀之一便是`Code Review`。这绝对不是一件易事，即便是Google，也花了很大的篇幅才说清楚他们在这一块的实践，感兴趣的朋友，可以来[<span style="color: orange">这里</span>](https://github.com/google/eng-practices/blob/master/review/reviewer/index.md)看看。很多代码管理平台，都自带了`code review`的特性，如`github`/`gitlab`/`gitee`等，也有对这一块做补充的Gerrit工具；前段时间，在`github`上看到了一个叫`ReviewDog`的产品，可以做到一些简单的自动化`review`工作，真感觉是个神器啊，必须respect一把。

- `持续测试`   
做到快速重复自动的测试，持续评估代码质量；这个过程主要是为了发现bug，确保主逻辑能走通；能做的测试很多，例如：
  * 单元测试：依赖于研发和QA及时编写和更新测试用例
  * 集成测试：多feature同时上线时的多功能测试阶段
  * 性能测试：服务接口上线前的压力测试

- `代码分析`   
可以做的<strong>lint</strong>检测很多，市面上也有很多工具平台，包括但不限于<u><span style="color: orange">SonarQube</span></u>、<u><span style="color: orange">TeskLink</span></u>、<u><span style="color: orange">FindBugs</span></u>、<u><span style="color: orange">CheckStyles</span></u>等。除了这些，我们可能还会做安全漏洞扫描，以及自定义的lint检测任务。
---

## 设计实现
终于来到了，大伙儿最关心的设计实现环节；其实，实现持续集成的过程，就是将上述组成模块拼接到一块，形成自动化的流水线；而一套`CI`的设计与实现，往往跟一家公司的规模、发展阶段、以及所使用的技术栈紧密相关，当然也可能包含有很重的历史包袱，这里给出几个范例，具体还需要大伙儿结合自身场景出发。
### 典型场景
![典型场景](classic_case.png)
### 微服务场景
![微服务场景](microservice_case.png)
其实总的来说，也就那么两条路子，要么自研、要么使用开源版；有能力和时间的公司，往往会选择自研，毕竟开源版，很多功能都是受限的，也无法很好地融入到企业技术栈，需要深度定制；所以你会发现，基于开源版二次开发，往往是大部分公司的路子。
