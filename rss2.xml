<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>春暖花开</title>
    <link>http://HQ1363.github.io/</link>
    
    <atom:link href="http://hq1363.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>这一路收获的不只是美丽的风景, 还有一份厚重充实、满满幸福的乐观豁达心情</description>
    <pubDate>Sun, 18 Jun 2023 13:15:34 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>CI缓存加速实践</title>
      <link>http://hq1363.github.io/2023/06/18/build_cache/</link>
      <guid>http://hq1363.github.io/2023/06/18/build_cache/</guid>
      <pubDate>Sun, 18 Jun 2023 10:36:50 GMT</pubDate>
      
      <description>像Java/Go/Node/Python构建都是需要下载依赖的，如何加速构建，减少研发CICD的等待时间显得尤为重要.</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Java-缓存"><a href="#Java-缓存" class="headerlink" title="Java 缓存"></a>Java 缓存</h2><blockquote><p>我们知道Java的缓存配置，对于Maven构建，是由settings文件指定的，一般是全局共用的本地缓存，当然我们也可以在执行mvn命令的时候，指定<code>-s</code>参数来设置settings文件，具体的配置项如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;localRepository&gt;<span class="regexp">/root/</span>.m2/repository&lt;/localRepository&gt;</span><br></pre></td></tr></table></figure><p>目前实践下来的缓存思路是按仓库来隔离每一个缓存，这么做的原因是：我们经常遇到不同仓库/应用之间的依赖相互影响，导致经常性出现缓存脏了的构建问题，处理起来很头疼.</p><h2 id="Go-缓存"><a href="#Go-缓存" class="headerlink" title="Go 缓存"></a>Go 缓存</h2><p>只缓存<code>GOCACHE</code>和<code>GOMODCACHE</code>目录，同时按仓库级别做隔离.</p><h2 id="Node-缓存"><a href="#Node-缓存" class="headerlink" title="Node 缓存"></a>Node 缓存</h2><p>缓存<code>NPM_CONFIG_CACHE</code>和<code>YARN_CACHE_FOLDER</code>目录，其次就是<code>node_modules</code>目录了，按仓库做隔离，然后动态挂载到对应构建仓库的<code>node_modules</code>目录上. </p><h3 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h3><ul><li>node仓库未按仓库做隔离，导致出现奇奇怪怪的缓存问题</li><li>使用软链的方式做仓库隔离，构建失败，没有用</li><li>使用cp/mv的方式做仓库隔离，磁盘IO非常慢，小文件又众多，跨磁盘mv/cp，简直是噩梦</li><li>使用mount的方式，挂载进去，又提示权限问题（内部系统不允许直接mount命令操作，允许的话，此方案可行）</li><li>基于k8s的磁盘挂载方式，实现动态挂载</li><li>清理node/go/java等缓存目录，简直是噩梦，速度非常非常慢，建议mv或者格式化操作</li></ul>]]></content:encoded>
      
      
      <category domain="http://HQ1363.github.io/categories/cache/">cache</category>
      
      
      <category domain="http://HQ1363.github.io/tags/cicd/">cicd</category>
      
      <category domain="http://HQ1363.github.io/tags/cache/">cache</category>
      
      
      <comments>http://hq1363.github.io/2023/06/18/build_cache/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>常用SQL指南</title>
      <link>http://hq1363.github.io/2023/06/18/sql/</link>
      <guid>http://hq1363.github.io/2023/06/18/sql/</guid>
      <pubDate>Sun, 18 Jun 2023 06:36:50 GMT</pubDate>
      
      <description>日常开发工作中，经常需要和SQL打交道，好的SQL姿势可以事半功倍.</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="多行合成一行"><a href="#多行合成一行" class="headerlink" title="多行合成一行"></a>多行合成一行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select `daily_plan_id`, GROUP_CONCAT( `pp_id` SEPARATOR &#x27;,&#x27;) as pp_ids, count(1) FROM `table_a` GROUP BY `daily_plan_id`;</span><br><span class="line"></span><br><span class="line">select group_concat(id) from table_a where repo in (&#x27;xxxx&#x27;, &#x27;yyyy&#x27;) and type = &#x27;push&#x27; and enabled = 1;</span><br></pre></td></tr></table></figure><h3 id="多列合成一列"><a href="#多列合成一列" class="headerlink" title="多列合成一列"></a>多列合成一列</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">  concat_ws(&#x27;#&#x27;, name, id, git_id, `git_namespace`)</span><br><span class="line">FROM</span><br><span class="line">  `table_a`</span><br><span class="line">where</span><br><span class="line">  name in (</span><br><span class="line">    &#x27;xxxx&#x27;,</span><br><span class="line">    &#x27;yyyy&#x27;,</span><br><span class="line">    &#x27;zzzz&#x27;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><h3 id="Case-When语句"><a href="#Case-When语句" class="headerlink" title="Case When语句"></a>Case When语句</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">case</span> 1</span></span><br><span class="line">select * from (select id, created_at, plan_id, ref, commit, CASE status</span><br><span class="line">    WHEN 2 THEN &#x27;成功&#x27;</span><br><span class="line">    WHEN 3 THEN &#x27;失败&#x27;</span><br><span class="line">    ELSE &#x27;运行中&#x27;</span><br><span class="line">  END as &#x27;流水线状态&#x27;, repo, repo_id from table_a where plan_id in (223,453) and created_at BETWEEN &quot;2023-03-23 00:00:00&quot; and &quot;2023-06-10 00:00:00&quot; and (ref like &quot;release%&quot; or ref like &quot;test%&quot;) and status in (1, 2, 3)) as cp left join (select `name`, type, pipeline_id, CASE status</span><br><span class="line">    WHEN 0 THEN &#x27;等待执行&#x27;</span><br><span class="line">    WHEN 1 THEN &#x27;初始化中&#x27;</span><br><span class="line">    WHEN 2 THEN &#x27;执行中&#x27;</span><br><span class="line">    WHEN 3 THEN &#x27;成功&#x27;</span><br><span class="line">    WHEN 4 THEN &#x27;失败&#x27;</span><br><span class="line">    WHEN 5 THEN &#x27;取消&#x27;</span><br><span class="line">    ELSE &#x27;未知&#x27;</span><br><span class="line">  END as &#x27;任务状态&#x27; from table_b where type = &#x27;build&#x27;) as cj on cp.id = cj.pipeline_id;</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">case</span> 2</span></span><br><span class="line">select bus, sum(num) from (</span><br><span class="line">    select case</span><br><span class="line">        when belong_id in (12) then &#x27;xxx&#x27;</span><br><span class="line">        when belong_id in (44,213) then &#x27;vvv&#x27;</span><br><span class="line">        else &#x27;未知&#x27;</span><br><span class="line">        end as bus, count(repo) as num from table_a where repo in (</span><br><span class="line">        &#x27;xxxx/yyyy&#x27;, &#x27;yyyy/zzzz&#x27;</span><br><span class="line">        ) GROUP BY belong_id) as bn GROUP BY bn.bus;</span><br></pre></td></tr></table></figure><h3 id="IF-语句"><a href="#IF-语句" class="headerlink" title="IF 语句"></a>IF 语句</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">case</span> 1</span></span><br><span class="line">SELECT</span><br><span class="line">  project_name,</span><br><span class="line">  repo,</span><br><span class="line">  env_name,</span><br><span class="line">  IF (json_extract(setting, &#x27;$.enabled&#x27;) = true, &#x27;开启&#x27;, &#x27;关闭&#x27;)</span><br><span class="line">FROM</span><br><span class="line">  `table_a`</span><br><span class="line">where</span><br><span class="line">  repo in (&#x27;xxxx&#x27;, &#x27;yyyy&#x27;);</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">case</span> 2</span></span><br><span class="line">SELECT if(id in(</span><br><span class="line">  select distinct(`table_b`.`project_id`)  from `table_b`</span><br><span class="line">    where `table_b`.`category`= &#x27;set&#x27;), &#x27;使用&#x27;, &#x27;不使用&#x27;)  as &#x27;状态&#x27;,</span><br><span class="line">       count(1)  as &#x27;数量&#x27;</span><br><span class="line">  from table_c;</span><br></pre></td></tr></table></figure><h3 id="中文乱码问题解决"><a href="#中文乱码问题解决" class="headerlink" title="中文乱码问题解决"></a>中文乱码问题解决</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">show variables like&#x27;%char%&#x27;;  # 查看</span><br><span class="line">set character_set_results=utf8;</span><br><span class="line">set character_set_client=utf8;</span><br><span class="line">set character_set_connection=utf8;</span><br><span class="line">set character_set_database=utf8;</span><br><span class="line">set character_set_results=utf8;</span><br></pre></td></tr></table></figure><h3 id="JSON字段处理"><a href="#JSON字段处理" class="headerlink" title="JSON字段处理"></a>JSON字段处理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * FROM table_a where JSON_TYPE(`extra_info`) = &#x27;NULL&#x27; limit 10;  # json_length(table_a.reason) = 0</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://HQ1363.github.io/categories/mysql/">mysql</category>
      
      
      <category domain="http://HQ1363.github.io/tags/mysql/">mysql</category>
      
      
      <comments>http://hq1363.github.io/2023/06/18/sql/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>pb应知应会</title>
      <link>http://hq1363.github.io/2022/01/03/pb/</link>
      <guid>http://hq1363.github.io/2022/01/03/pb/</guid>
      <pubDate>Mon, 03 Jan 2022 07:21:49 GMT</pubDate>
      
      <description>pb作为grpc的IDL语言，其自身具有极大的优点，但也存在一些使用上的问题；本文将介绍pb的规范、管理方式、以及优点和缺点。</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="pb简介"><a href="#pb简介" class="headerlink" title="pb简介"></a>pb简介</h2><blockquote><p>Protobuf是Protocol Buffers的简称，它是Google公司开发的一种数据描述语言，并于2008年对外开源。Protobuf刚开源时的定位类似于XML、JSON等数据描述语言，通过附带工具生成代码并实现将结构化数据序列化的功能。</p></blockquote><p>说的好抽象啊，我们来具象化一下：</p><blockquote><p>写过<code>thrift</code>的朋友，可能立马反应过来了，这东西也是用来定义消息以及消息是如何通信的嘛。都是为RPC服务，<u>我们知道RPC的作用，就是让远程过程调用，看起来像是本地调用一样；但实际上，是请求远端的服务，既然是请求远端的服务，我们肯定要知道对方的<span style="color: orange">服务名(service)</span>、<span style="color: orange">方法名(func)</span>、<span style="color: orange">消息结构(message/struct)</span>吖，不然我找谁去请求，我怎么去解析数据</u>。proto文件就是干这么一件事，所以proto也是一种描述性语言嘛。</p></blockquote><h3 id="pb的好处"><a href="#pb的好处" class="headerlink" title="pb的好处"></a>pb的好处</h3><blockquote><p><code>Protocol Buffers</code>是一种轻便高效的结构化数据存储格式，可以用于结构化数据的序列化，很适合做数据存储或 RPC 数据交换格式。它可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。</p></blockquote><p>听起来，设计rpc的通信协议，好像很简单，也没什么嘛，不就是简单的协议（语法、语义、时序）定义嘛！！！其实不然，这其中，需要考虑的问题很多，比如：<u style="color: orange">数据发送方如何序列化传输数据</u>、<u style="color: orange">数据接受方需要如何接收并反序列化数据</u>、<u style="color: orange">数据的传输效率如何提高</u>、<u style="color: orange">各种语言如何与pb语义对应上</u>等等。</p><h3 id="pb编码方式"><a href="#pb编码方式" class="headerlink" title="pb编码方式"></a>pb编码方式</h3><blockquote><p>在XML或JSON等数据描述语言中，一般通过成员的名字来绑定对应的数据。但是Protobuf编码却是通过成员的唯一编号来绑定对应的数据，因此Protobuf编码后数据的体积会比较小，但是也非常不便于人类查阅。</p></blockquote><h3 id="pb的使用"><a href="#pb的使用" class="headerlink" title="pb的使用"></a>pb的使用</h3><ul><li><code>.proto</code>文件的书写</li><li>使用IDL编译器编译成对应语言的代码</li></ul><h2 id="pb书写规范"><a href="#pb书写规范" class="headerlink" title="pb书写规范"></a><a href="https://developers.google.com/protocol-buffers/docs/style">pb书写规范</a></h2><ul><li><code>pb</code>文件名为小写+下划线形式，文件后缀以<code>.proto</code>结尾</li><li>保证每行80字符左右；请使用2个空格缩进</li><li>除结构定义之外的语句均以分号结尾</li><li>包名必须小写, 并应与目录层次结构相对应. 例如: test/pb/api.proto 包名应该为test.pb</li><li><code>message</code>结构体命名采用驼峰命名方式，字段命名采用小写字母加下划线分隔方式</li><li><code>enums</code>类型名采用驼峰命名方式，字段命名采用大写字母加下划线分隔方式</li><li><code>service</code>与<code>rpc</code>方法名统一采用驼峰式命名</li></ul><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定proto的版本，默认proto2；proto3对语言进行了提炼简化，所有成员均采用类似Go语言中的零值初始化（不再支持自定义默认值）</span></span><br><span class="line"><span class="comment">// 因此消息成员也不再需要支持required特性。</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义包名(import path)，防止message重名</span></span><br><span class="line"><span class="keyword">package</span> main;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入外部pb</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/timestamp.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加可选项</span></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;github.com/protocolbuffers/protobuf/examples/go/tutorialpb&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PersonType</span> </span>&#123;</span><br><span class="line">  WHITE = <span class="number">0</span>;</span><br><span class="line">  BLACK = <span class="number">1</span>;</span><br><span class="line">  YELLOW = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  PersonType type = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// Unique ID number for this person.</span></span><br><span class="line">  <span class="built_in">int32</span> id = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">string</span> email = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">PhoneType</span> </span>&#123;</span><br><span class="line">    MOBILE = <span class="number">0</span>;</span><br><span class="line">    HOME = <span class="number">1</span>;</span><br><span class="line">    WORK = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">message</span> <span class="title">PhoneNumber</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> number = <span class="number">1</span> [(gogoproto.jsontag) = <span class="string">&quot;number&quot;</span>, json_name = <span class="string">&quot;number&quot;</span> ];</span><br><span class="line">    PhoneType type = <span class="number">2</span> [(gogoproto.jsontag) = <span class="string">&quot;type&quot;</span>, json_name = <span class="string">&quot;type&quot;</span> ];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">repeated</span> PhoneNumber phones = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">  google.protobuf.Timestamp last_updated = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义message（可定义多个）</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">EntranceReq</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义字段： type fieldName = fieldNumber; </span></span><br><span class="line">  <span class="built_in">string</span> query = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">int32</span> result_per_page = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EntranceResp 入口返回结果</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">EntranceResp</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 图标</span></span><br><span class="line">    <span class="built_in">string</span> icon = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 名称</span></span><br><span class="line">    <span class="built_in">string</span> name = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义服务和方法</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 活动入口</span></span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> TestEntrance (EntranceReq) <span class="keyword">returns</span> (EntranceResp)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="划重点"><a href="#划重点" class="headerlink" title="划重点"></a>划重点</h3><h4 id="字段的fieldNumber"><a href="#字段的fieldNumber" class="headerlink" title="字段的fieldNumber"></a>字段的<code>fieldNumber</code></h4><blockquote><p>这个并不是<code>fieldName</code>的值，只是一个标号（<code>tag</code>），意味着：往后见到<code>fieldNumber</code>就代表是<code>fieldName</code>；换句话说，字段叫啥名在protobuf中并不重要, 因为在传输的时候，二进制数据流里用的是<code>fieldNumber</code>而不是<code>fieldName</code>；所以<code>fieldNumber</code>一旦被使用, 终生这个编号都不要改变，否则很可能引发线上故障，这也是为什么我们说pb字段的<code>fieldNumber</code>只能追加，不能修改，或者插入的原因。<br><code>fieldNumber</code>的取值范围是1~2^29-1. 而常用的<code>fieldNumber</code>范围是: 1-15(只用1个byte编码),  16-2047(采用2个byte编码). 所以为了节省编码后的长度, 经常使用的一些字段名(如:name, id等), 分配1-15的<code>fieldNumber</code>.</p></blockquote><h4 id="字段的定义"><a href="#字段的定义" class="headerlink" title="字段的定义"></a>字段的定义</h4><ul><li>singular单数字段: protobuf的默认字段规则, 就是说这个字段只能出现0或者1次.</li><li>repeated重复字段: 代表该字段是一个数组或者list. 数组里面可以有任意数量的元素. 如果有多个元素, 元素的顺序会被保留.</li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Shop</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int32</span> id = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 商店会有多个服务员</span></span><br><span class="line">  <span class="keyword">repeated</span> <span class="built_in">string</span> staff = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="保留字段"><a href="#保留字段" class="headerlink" title="保留字段"></a>保留字段</h4><blockquote><p>保留字段的意思就是, 这些字段保留下来, 后续在protobuf中,不能再次使用了.(即: 防止字段名一样, 但是字段含义不同)</p></blockquote><p>案例说明</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">reserved <span class="number">2</span>, <span class="number">3</span> to <span class="number">7</span>; <span class="comment">// 保留这几个fieldNumber</span></span><br><span class="line">    reserved <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>; <span class="comment">// 保留这几个字段名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子解释下为啥要保留字段</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一开始的需求, UserInfo绑定的是微信的账号和密码</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line"><span class="built_in">int32</span> Id = <span class="number">1</span>;</span><br><span class="line">    stirng name = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> wechat_account = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">string</span> wechat_pwd = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在需求变了,要求用户信息绑定QQ账号密码</span></span><br><span class="line"><span class="comment">// 此时我删除了 wechat_account wechat_pwd两个字段, 并添加QQ_account, QQ_pwd</span></span><br><span class="line"><span class="comment">// 同时, 之前分配给wechat_account和wechat_pwd的fieldNumber 3 4, 又再一次分配给了 QQ_account和QQ_pwd.</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line"><span class="built_in">int32</span> Id = <span class="number">1</span>;</span><br><span class="line">    stirng name = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> QQ_account = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">string</span> QQ_pwd = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 想想会有什么问题?</span></span><br><span class="line"><span class="comment">// 别想了,我直接说了, 假如server端修改了protobuf的定义,但是client端还没有更新.</span></span><br><span class="line"><span class="comment">// 此时, 客户端传给server微信的账号/密码, 服务端作为QQ的账号密码去验证,肯定是错的.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以呢? 所以修改(如删掉)的字段和对应的fieldNumber都应该保留, 后续都不能在使用了.</span></span><br></pre></td></tr></table></figure><h4 id="enum-枚举类型"><a href="#enum-枚举类型" class="headerlink" title="enum 枚举类型"></a><code>enum</code> 枚举类型</h4><blockquote><p>枚举可以定义在message里面,也可以定义在外面(便于复用)；在另一个message类型中,可以通过UserInfo.Gender, 使用枚举类型. reserved同样也可以适用于枚举类型.</p></blockquote><p>案例说明</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Gender gender = <span class="number">1</span>; <span class="comment">// 使用Gender枚举类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义枚举类型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Gender</span> </span>&#123;</span><br><span class="line">    FEMAIL = <span class="number">0</span>; <span class="comment">// 必须从0开始</span></span><br><span class="line">        MAIL = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="message类型"><a href="#message类型" class="headerlink" title="message类型"></a><code>message</code>类型</h4><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="built_in">int32</span> id = <span class="number">1</span>; </span><br><span class="line">    <span class="built_in">string</span> name = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    Date birthday = <span class="number">3</span>; <span class="comment">// 使用message类型作为字段的type</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义消息类型Date:生日</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Date</span> </span>&#123;</span><br><span class="line">    <span class="built_in">int32</span> year = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int32</span> mounth = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">int32</span> day = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tips：一般来说,不相关的消息, 每个message,创建一个proto文件. 如果需要用到其他.proto文件中定义的message, 要通过import进行引入. 编译器会在–proto_path参数指定的路径下寻找相应的需要导入的proto文件. 不写默认在当前目录寻找.</p><h4 id="package包名"><a href="#package包名" class="headerlink" title="package包名"></a><code>package</code>包名</h4><blockquote><p>给一个.proto文件指定package, 是为了避免和其他的.proto文件的message名称冲突.</p></blockquote><p>案例说明</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bar.proto</span></span><br><span class="line"><span class="keyword">package</span> foo.bar;</span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Open</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>后面可以使用该.proto文件的包名去使用message Open</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.proto</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;bar.proto&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  foo.bar.Open open = <span class="number">1</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当被IDL编译器翻译成GO语言后, Go代码的包名, 默认就是.proto文件的pacakge名称, 除非在.proto文件中显示的用go_pacakge指定IDL编译后的Go文件的import path.</p><h4 id="import的搜寻路径是？"><a href="#import的搜寻路径是？" class="headerlink" title="import的搜寻路径是？"></a>import的搜寻路径是？</h4><blockquote><p>搜寻路径由protoc -I或者protoc –proto_path指定. 所以, import 要和 protoc -I/–proto_path 命令配合好.</p></blockquote><h3 id="踩坑笔记"><a href="#踩坑笔记" class="headerlink" title="踩坑笔记"></a>踩坑笔记</h3><ul><li>任何地方的命名，都不要使用关键字，会出问题</li><li>java_package中，包含关键字（如：public / interface）</li><li>pb文件中，混入奇怪的不可打印字符，或者是混入无用的、语法不对的字符</li><li>enum和message名字不一样就好</li><li>message的名字不要和文件名一样，小心踩坑</li></ul><h2 id="pb管理办法"><a href="#pb管理办法" class="headerlink" title="pb管理办法"></a>pb管理办法</h2><blockquote><p>pb是好用，可是如何优雅的管理起来，是个头疼的问题；微服务化后，多人协作开发上，就很容易出问题。不禁引人发问：proto这个IDL的代码到底应该放在哪里，该怎么管理？这里简单讨论下</p></blockquote><p>能够想到的几种方式如下：</p><ul><li>代码仓库</li><li>独立仓库</li><li>集中仓库</li><li>镜像仓库</li><li>组合方式</li></ul><h3 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h3><p>直接将项目所依赖的所有proto文件都存放在项目的<code>proto/</code>目录下，不经过开发工具的自动拉取和发布：</p><div>  <img data-src="manage1.png" width="300px" alt="代码仓库"></div><ul><li>优点<ul><li>项目所有依赖的 Proto 都存储在代码仓库下，因此不涉及个人开仓库权限的问题。</li><li>多 Proto 的切换开销减少，因为都在代码仓库下，不需要看这看那。</li></ul></li><li>缺点<ul><li>项目所有依赖的 Proto 都存储在代码仓库下，因此所有依赖 Proto 都需要人工的向其它业务组 “要” 来，再放到 proto/ 目录下，人工介入极度麻烦。</li><li>Proto 升级和变更，经常要重复第一步，沟通成本高。</li></ul></li></ul><h3 id="独立仓库"><a href="#独立仓库" class="headerlink" title="独立仓库"></a>独立仓库</h3><blockquote><p>独立仓库存储是我们最早采取的方式，也就是每个服务对应配套一个 Proto 仓库</p></blockquote><div>  <img data-src="manage2.png" width="400px" alt="独立仓库"></div><p>这个方案的好处就是可以独立管理所有 Proto 仓库，并且权限划分清晰。但最大的优点也是最大的缺点。因为一个服务会依赖多个 Proto 仓库，并且存在跨业务组调用的情况</p><div>  <img data-src="manage3.png" width="400px" alt="独立仓库"></div><p>如上图所示，svc-user 服务分别依赖了三块 Proto 仓库，分别是自己组的、业务组 A、业务组 B 总共的 6 个 Proto 仓库。</p><ul><li>优点<ul><li>使得安全性较高（但 IDL 本身没有太多的秘密）。</li><li>按需拉取，不需要关注其余的服务 Proto。</li></ul></li><li>缺点<ul><li>假设你是一个新入职的开发人员，那么你就需要找不同的业务组申请不同的仓库权限，非常麻烦。如果没有批量赋权工具，也没有管理者权限，那么就需要一个个赋权，非常麻烦。</li><li>在运行服务的时候，你需要将所有相关联的 Proto 仓库拉取下来，如果没有工具做半自动化的支持，麻烦程度无法忍受。</li></ul></li></ul><h3 id="集中仓库"><a href="#集中仓库" class="headerlink" title="集中仓库"></a>集中仓库</h3><blockquote><p>集中仓库也是一些公司考虑的方式之一，是按公司或大事业部的维度进行 Proto 代码的存储。这样子只需要拉取一个仓库，就可以获取到所有所需的IDL.</p></blockquote><div>  <img data-src="manage4.png" width="400px" alt="集中仓库"></div><ul><li>优点<ul><li>只需要拉取一次Proto仓库就可以轻松把一个服务所需的 IDL 集齐。</li><li>仓库权限管理的复杂度下降。</li></ul></li><li>缺点<ul><li>安全性下降，因为其它业务组的IDL也全都 “泄露” 了。</li><li>非按需拉取，在查看原始文件时，需要关注一些多余的。</li></ul></li></ul><h3 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h3><blockquote><p>自己服务的 Proto 文件存放在代码仓库的 proto 文件中，在本次 feature 提交或发布后，自动同步到镜像仓库去。你所依赖的其他服务 Proto 则直接通过读取集中的镜像仓库的方式获取.</p></blockquote><div>  <img data-src="manage5.png" width="500px" alt="镜像仓库"></div><p>这样子的话，通过开发工具的配合，开发人员在开发时就只需要关注自己项目的 Proto 就好了。集中的镜像仓库主要用于构建和部署，大幅度降低了多Proto的关注和切换开销。</p><h3 id="组合方式"><a href="#组合方式" class="headerlink" title="组合方式"></a>组合方式</h3><blockquote><p>单一的方式，或多或少的都存在一些问题，如果采用组合的方式，可以最大程度地发挥作用。例如：独立仓库+集中仓库，对于公共的、需要暴露出去的部分放到集中仓库，不需要暴露出去的就放到独立仓库（例如：部门内部的，可以放到独立仓库，需要跨部门的，可以放到集中仓库），可以一定程度上降低安全性问题。</p></blockquote><p>实际工作中，我们不仅需要考虑proto文件的管理，还需要管理proto编译产物的管理，而这个过程，需要考虑到区分版本的问题，因为测试和上线是两个不同的阶段，不能让测试的版本，被用到了线上。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://juejin.cn/post/6865126893063471112">Protobuf入门（大白话版）</a></li><li><a href="https://mp.weixin.qq.com/s/cBXZjg_R8MLFDJyFtpjVVQ">真是头疼，Proto 代码到底放哪里？</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://HQ1363.github.io/categories/go/">go</category>
      
      <category domain="http://HQ1363.github.io/categories/go/grpc/">grpc</category>
      
      <category domain="http://HQ1363.github.io/categories/go/grpc/pb/">pb</category>
      
      
      <category domain="http://HQ1363.github.io/tags/pb/">pb</category>
      
      
      <comments>http://hq1363.github.io/2022/01/03/pb/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>前端常见面试题</title>
      <link>http://hq1363.github.io/2021/09/27/frontend-interview/</link>
      <guid>http://hq1363.github.io/2021/09/27/frontend-interview/</guid>
      <pubDate>Mon, 27 Sep 2021 04:01:40 GMT</pubDate>
      
      <description>最近公司在招人，面了挺多人，这里总结下招人的心得和常见问题.</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="前端工程师"><a href="#前端工程师" class="headerlink" title="前端工程师"></a>前端工程师</h2><h3 id="技能要求"><a href="#技能要求" class="headerlink" title="技能要求"></a>技能要求</h3><ul><li>熟悉<code>Vue</code>/<code>React</code>其中一种</li><li>熟悉<code>Webpack</code>配置</li><li>精通<code>Html5</code>、<code>Javascript</code>，熟练掌握主流<code>mvc</code>、<code>mvvm</code>前端框架</li><li>具备良好的数据结构和算法知识</li><li>对前端有浓厚的兴趣，具有快速学习能力，乐于探索，并有良好的编码习惯</li></ul><h3 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h3><ul><li>vue指令，v-show指令和v-if指令的区别是什么？</li><li>data为什么是一个函数而不是对象</li><li>vue常用指令<ul><li>v-model 多用于表单元素实现双向数据绑定（同angular中的ng-model）</li><li>v-bind 动态绑定 作用： 及时对页面的数据进行更改</li><li>v-on:click 给标签绑定函数，可以缩写为@，例如绑定一个点击函数 函数必须写在methods里面</li><li>v-for 格式： v-for=”字段名 in(of) 数组json” 循环数组或json(同angular中的ng-repeat)</li><li>v-show 显示内容 （同angular中的ng-show）</li><li>v-hide 隐藏内容（同angular中的ng-hide）</li><li>v-if 显示与隐藏 （dom元素的删除添加 同angular中的ng-if 默认值为false）</li><li>v-else-if 必须和v-if连用</li><li>v-else 必须和v-if连用 不能单独使用 否则报错 模板编译错误</li><li>v-text 解析文本</li><li>v-html 解析html标签</li><li>v-bind:class 三种绑定方法 1、对象型 ‘{red:isred}’ 2、三元型 ‘isred?”red”:”blue”‘ 3、数组型 ‘[{red:”isred”},{blue:”isblue”}]’</li><li>v-once 进入页面时 只渲染一次 不在进行渲染</li><li>v-cloak 防止闪烁</li><li>v-pre 把标签内部的元素原位输出</li></ul></li><li>组件传值方式有哪些，父子之间的数据如果需要相互访问，可以有哪些方式？<ul><li>父传子：子组件通过props[‘xx’] 来接收父组件传递的属性 xx 的值</li><li>子传父：子组件通过 this.$emit(‘fnName’,value) 来传递,父组件通过接收 fnName 事件方法来接收回调</li><li>使用Vuex</li></ul></li><li>vuex的核心概念<ul><li>state =&gt; 基本数据</li><li>getters =&gt; 从基本数据派生的数据</li><li>mutations =&gt; 修改数据，同步</li><li>actions =&gt; 修改数据，异步 (Action 提交的是 mutation，而不是直接变更状态)</li><li>modules =&gt; 模块化Vuex</li></ul></li><li>目前的前端开发架子，是？<ul><li>路由是用哪个库？</li><li>UI组件是哪个？</li><li>css解析是哪个？</li><li>ajax异步接口请求，用的是哪个库？</li><li>图表类库，都用过哪些</li><li>全局状态维护，用的是哪个库？</li></ul></li><li>css如何只在当前组件起作用？</li><li>vue实现数据双向绑定的原理</li><li>vue的生命周期函数，都有哪些？</li><li>css的选择器，都有哪些？</li><li>cookie和session的区别</li><li>localStorage和SessionStorage的区别</li><li>get和post的区别</li><li>说一说http的缓存</li><li>常见状态码的含义和产生原因</li><li>从浏览器输入url后都经历了什么</li></ul>]]></content:encoded>
      
      
      <category domain="http://HQ1363.github.io/categories/vue/">vue</category>
      
      <category domain="http://HQ1363.github.io/categories/vue/javascript/">javascript</category>
      
      <category domain="http://HQ1363.github.io/categories/vue/javascript/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <category domain="http://HQ1363.github.io/tags/vue/">vue</category>
      
      <category domain="http://HQ1363.github.io/tags/javascript/">javascript</category>
      
      <category domain="http://HQ1363.github.io/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>http://hq1363.github.io/2021/09/27/frontend-interview/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>学习GPRC，这篇就够了</title>
      <link>http://hq1363.github.io/2021/09/14/grpc-intro/</link>
      <guid>http://hq1363.github.io/2021/09/14/grpc-intro/</guid>
      <pubDate>Tue, 14 Sep 2021 02:25:09 GMT</pubDate>
      
      <description>gRPC 是一个高性能、开源和通用的 RPC 框架，面向移动和 HTTP/2 设计。目前提供 C、Java 和 Go 语言版本，分别是：grpc, grpc-java, grpc-go</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="GRPC简介"><a href="#GRPC简介" class="headerlink" title="GRPC简介"></a>GRPC简介</h2>]]></content:encoded>
      
      
      <category domain="http://HQ1363.github.io/categories/grpc/">grpc</category>
      
      
      <category domain="http://HQ1363.github.io/tags/go/">go</category>
      
      <category domain="http://HQ1363.github.io/tags/grpc/">grpc</category>
      
      
      <comments>http://hq1363.github.io/2021/09/14/grpc-intro/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>gorm血泪史</title>
      <link>http://hq1363.github.io/2021/09/10/go-gorm-blood-tears/</link>
      <guid>http://hq1363.github.io/2021/09/10/go-gorm-blood-tears/</guid>
      <pubDate>Fri, 10 Sep 2021 04:03:49 GMT</pubDate>
      
      <description>如果你用过gorm，只希望各位大佬不要踩这些坑，每一个都是血和泪的教训。</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="Rows没有Close"><a href="#Rows没有Close" class="headerlink" title="Rows没有Close"></a>Rows没有Close</h3><blockquote><p><strong>上下文</strong>：有个实习生，写了一个需求，结果for循环到第十次的时候，一直卡死，没有任何响应，最终请求超时；不仅如此，后续的接口请求，都是没有处理的，整个程序仿佛处于假死状态。这让当时的我感到十分诧异，我的第一个感觉是存在死循环，为了证实猜想，开始对整个for循环体做单步调试，结果发现，并不存在死循环，程序卡在某个SQL执行处；于是我就想，难道是慢SQL，导致一直从DB拿不到返回结果，但很快我就排除了这种可能性，毕竟问题是发生第十次，而不是第一次；在问题稳定复现后，我开始总结规律，问题复现一定是在for循环执行到第十次的时候，就有这么巧吗，回回都是第十次，也太邪乎了。</p></blockquote><p><u>针对上述的问题，毫无疑问，肯定是出了DB上的问题，然后又是第十次稳定复现，我开始怀疑DB连接的问题，比如连接被吃满，不够用</u>；于是乎，我开始检查程序连接DB的配置，发现active激活连接数，配置的最大值就是10个，这不刚好就是10嘛，<span style="color:orange">这不是巧了嘛！这不是巧了嘛！</span>那就调大嘛，结果然并软，反而换了一个报错<u>（MySQL error code 1135 (ER_CANT_CREATE_THREAD): Can’t create a new thread (errno %d); if you are not out of available memory, you can consult the manual for a possible OS-dependent bug）</u>，这又是什么鬼啊，why！！！<br><img data-src="question.jpeg">哼，不陪你玩了，哪儿凉快哪儿呆着去吧；哈哈，回到正题，不然要被你们打😄</p><p><strong style="font-size:20px;color:blue">难道不是连接的问题吗，我开始更换思路</strong>；我的SQL请求到底有没有打到MySQL服务器呢，我开始求助DBA，希望帮捞下，第十次的SQL执行日志，得到的反馈是一切正常。what，不对啊；因为程序DB操作，用的是Gorm，我开始查阅官方文档，搜索github上的issue，并为找到任何有用的消息。对新出现的error信息，同向DBA老师求证后，排除了，没办法，我只能把连接配置，改回去，继续排查问题。然后一步步的检查代码，发现DB操作，<u style="color:red">少了一个释放连接的动作</u>，于是我加上，赶紧验证了一下，好在问题得到解决了。<br><img data-src="good.jpeg">我们来看看代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生 SQL</span></span><br><span class="line">rows, err := db.Raw(<span class="string">&quot;select name, age, email from users where name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Rows()</span><br><span class="line"><span class="keyword">defer</span> rows.Close()   <span class="comment">// 就是这行代码少了，导致的</span></span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">  rows.Scan(&amp;name, &amp;age, &amp;email)</span><br><span class="line">  <span class="comment">// 业务逻辑...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查阅资料后，大胆猜测：<u>有可能是mysql每次去查询的时候，获取一个连接，没有空闲的连接，则创建一个新的，查询完成后释放连接到连接池，以便下一个请求使用，而由于没有调用rows.Close()，导致拿了连接之后，没有再放回连接池复用；而我的连接配置最大就是10，所以在第十次执行完后，第十一次，已经无法分配新的连接去执行SQL，最终一直等待，拿不到结果。</u><a href="https://segmentfault.com/a/1190000021493463" target="_blank">感兴趣的朋友，可以看看这篇文章，基于gorm源码解释了问题原因</a>；未执行rows.Close()还可能导致内存泄漏、启动一堆的goroutine不退出等问题。</p>]]></content:encoded>
      
      
      <category domain="http://HQ1363.github.io/categories/gorm/">gorm</category>
      
      
      <category domain="http://HQ1363.github.io/tags/gorm/">gorm</category>
      
      <category domain="http://HQ1363.github.io/tags/go/">go</category>
      
      
      <comments>http://hq1363.github.io/2021/09/10/go-gorm-blood-tears/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>K8S常见指令</title>
      <link>http://hq1363.github.io/2021/09/07/k8s-intro/</link>
      <guid>http://hq1363.github.io/2021/09/07/k8s-intro/</guid>
      <pubDate>Tue, 07 Sep 2021 08:20:46 GMT</pubDate>
      
      <description>分享一些K8S和Docker实用小技巧，走过路过，不要错过嘛.</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="K8S"><a href="#K8S" class="headerlink" title="K8S"></a>K8S</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl == kubernetes + control  <span class="comment"># 即：k8s控制器</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get namespace  <span class="comment"># 查询物理cluster下拆分出的namespace信息</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get node  <span class="comment"># 查看k8s集群有哪些k8s节点</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pod -ndevga -owide -w |grep -i secrets-distribution-admin</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl -ndevga describe deploy secrets-distribution-admin-devga</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get po pod-redis -o yaml  <span class="comment"># 以yaml文件形式显示一个pod的详细信息</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get po &lt;podname&gt; -o json  <span class="comment"># 以json形式显示一个pod的详细信息</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe po rc-nginx-3-l8v2r</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl delete -f rc-nginx.yaml</span>   </span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl delete po rc-nginx-btv4j</span>   </span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl delete po -lapp=nginx-2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl -n prodbj <span class="built_in">exec</span> nginx-2476590065-1vtsp  -it sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get service</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get service nginx -o yaml &gt; nginx_forreplace.yaml</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl -n qa rollback status deployment xxxxxxx</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl -n qa rollback resume deployment xxxxxxx</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl rollout <span class="built_in">history</span> deployment cargo-detail-dev -n dev  <span class="comment"># 滚动发布的历史记录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl rollout undo deployment cargo-detail-dev -n dev --to-revision=7  <span class="comment"># 回滚到指定的某个版本</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl rollout restart deploy xxxxx</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl -n qa get crd  <span class="comment"># 获取所有的自定义资源</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> node节点打标</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl -n qa lable nodes ip/name key=value  <span class="comment"># 加标签</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl -n qa lable nodes ip/name key=value --overwrite  <span class="comment"># 更新</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl -n qa lable nodes ip/name key-  <span class="comment"># 删除标签</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl -n qa edit node ip/name  <span class="comment"># 编辑node资源   -- 看起来node节点可以同时打多个标签，倒也合理</span></span></span><br></pre></td></tr></table></figure><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker stop jenkins</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker rm jenkins</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -d \</span></span><br><span class="line"><span class="bash">    --name jenkins \</span></span><br><span class="line"><span class="bash">    -p 18101:8080 \</span></span><br><span class="line"><span class="bash">    -p 50000:50000 \</span></span><br><span class="line"><span class="bash">    -v /srv/jenkins:/var/jenkins_home \</span></span><br><span class="line"><span class="bash">    -v /usr/<span class="built_in">local</span>/maven:/usr/<span class="built_in">local</span>/maven \</span></span><br><span class="line"><span class="bash">    -v /usr/<span class="built_in">local</span>/jdk:/usr/<span class="built_in">local</span>/jdk  \</span></span><br><span class="line"><span class="bash">    -v /etc/localtime:/etc/localtime \</span></span><br><span class="line"><span class="bash">    -v /etc/timezone:/etc/timezone \</span></span><br><span class="line"><span class="bash">    -u root \</span></span><br><span class="line"><span class="bash">    jenkins/jenkins:latest</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">  --link gitlab:47.97.174.90 \</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/env bash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> host_name=gitlab.virtual.vm</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gitlab_dir=/srv/gitlab</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker stop gitlab</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> docker rm gitlab</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -d \</span></span><br><span class="line"><span class="bash">  --hostname <span class="variable">$&#123;host_name&#125;</span> \</span></span><br><span class="line"><span class="bash">  -p 8443:443 -p 1080:80 -p 2222:22 \</span></span><br><span class="line"><span class="bash">  --name gitlab \</span></span><br><span class="line"><span class="bash">  --restart always \</span></span><br><span class="line"><span class="bash">  --env gitlab_rails[<span class="string">&#x27;SIDEKIQ_MEMORY_KILLER_MAX_RSS&#x27;</span>]=2048 \</span></span><br><span class="line"><span class="bash">  -v <span class="variable">$&#123;gitlab_dir&#125;</span>/config:/etc/gitlab \</span></span><br><span class="line"><span class="bash">  -v <span class="variable">$&#123;gitlab_dir&#125;</span>/logs:/var/<span class="built_in">log</span>/gitlab \</span></span><br><span class="line"><span class="bash">  -v <span class="variable">$&#123;gitlab_dir&#125;</span>/data:/var/opt/gitlab \</span></span><br><span class="line"><span class="bash">  -v /var/run/docker.sock:/run/docker.sock \</span></span><br><span class="line"><span class="bash">  registry.cn-hangzhou.aliyuncs.com/imooc/gitlab-ce:latest</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image inspect image-name</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker inspect container-name</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker port container-name</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">kill</span>/start/stop container-name</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker pull jenkins打包日志里的镜像名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run --name cargo-test -u root --rm -P  harbor.test.com/app/cargo-test:python-dev-jdk8-20200109_161946 python3 -c <span class="string">&quot;import schedule&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -it --name testmock -u root --rm -P harbor.test.com/app/testmock:python-master-jdk8-20200407_143644 bash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker run -it --entrypoint /bin/bash --name bapis-pre -u root --rm -P hub.test.co/k8s-prow/bapis-pre:v0.0.7</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 常用docker命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 1、删除所有镜像</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker rmi $(docker images -q) -f</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、删除所有容器</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker stop $(docker ps -q) &amp; docker rm $(docker ps -aq)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有容器：</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> docker ps -a</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看运行容器：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker ps</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 停用所有容器：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker stop $(docker ps -q)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除所有容器：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker rm $(docker ps -aq)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 停用和删除所有容器：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker stop $(docker ps -q) &amp; docker rm $(docker ps -aq)</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://HQ1363.github.io/categories/K8S/">K8S</category>
      
      
      <category domain="http://HQ1363.github.io/tags/K8S/">K8S</category>
      
      <category domain="http://HQ1363.github.io/tags/Docker/">Docker</category>
      
      
      <comments>http://hq1363.github.io/2021/09/07/k8s-intro/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>git操作指南</title>
      <link>http://hq1363.github.io/2021/08/02/git-ops/</link>
      <guid>http://hq1363.github.io/2021/08/02/git-ops/</guid>
      <pubDate>Mon, 02 Aug 2021 06:36:50 GMT</pubDate>
      
      <description>git已然成为开发的必备技能了，来看看有哪些相见恨晚的小技巧吧，可别说我没告诉你哦.</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Git-SubModule"><a href="#Git-SubModule" class="headerlink" title="Git SubModule"></a>Git SubModule</h2><h3 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git submodule init &amp;&amp; git submodule update   <span class="comment"># 将子模块下载到本地</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/xx/xx.git --recursive  <span class="comment"># 此命令可一次性下载好主库和子库</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git submodule sync  <span class="comment"># 修改.gitmodule文件后，用此命令同步子模块信息</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git submodule add https://github.com/xxxx/xxxxx.git  <span class="comment"># 添加submodule</span></span></span><br></pre></td></tr></table></figure><h3 id="批量操作submodule"><a href="#批量操作submodule" class="headerlink" title="批量操作submodule"></a>批量操作submodule</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git submodule foreach &lt;<span class="built_in">command</span>&gt;</span></span><br><span class="line">比如:</span><br><span class="line"><span class="meta">$</span><span class="bash"> git submodule foreach git checkout master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git submodule foreach git submodule update</span></span><br></pre></td></tr></table></figure><h3 id="删除git-submodule"><a href="#删除git-submodule" class="headerlink" title="删除git submodule"></a>删除git submodule</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add .gitmodules        <span class="comment"># 第一步</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm --cached submodule_name    <span class="comment"># 第二步</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> rm -rf submodule_name   <span class="comment"># 第三步：删除submodule目录</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第四步：编辑.gitmodules文件, 移除对应的submodule信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第五步：编辑.git/modules文件, 移除对应的submodule信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第六步：编辑.git/config 移除对应的submodule信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ===== 上述方式不行，可尝试下述</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git submodule deinit &lt;submodule-name&gt; <span class="comment"># 新版git</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ===== 上述方式不行，可尝试下述</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm &lt;submodule-name&gt; <span class="comment"># 旧版git</span></span></span><br></pre></td></tr></table></figure><h3 id="子仓如何与远端保持同步"><a href="#子仓如何与远端保持同步" class="headerlink" title="子仓如何与远端保持同步"></a>子仓如何与远端保持同步</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 子仓的更新，是单独的，需要进入子仓目录，手动与远端同步，例如：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> sub-dir &amp;&amp; git fetch origin master &amp;&amp; git rebase origin/master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 完成同步后，需要在主仓下提交子仓的改动，以保存主仓对子仓的最新引用</span></span><br></pre></td></tr></table></figure><h2 id="Git-Ops"><a href="#Git-Ops" class="headerlink" title="Git Ops"></a>Git Ops</h2><h3 id="查看last-commitId"><a href="#查看last-commitId" class="headerlink" title="查看last commitId"></a>查看last commitId</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -1 --pretty=format:%H <span class="comment"># 完整的</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出 7b6b2803d2b7135b239d062847816e55a810371e</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -1 --pretty=format:%h <span class="comment"># 前7位</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出 7b6b280</span></span><br></pre></td></tr></table></figure><h3 id="查看某次commit的内容"><a href="#查看某次commit的内容" class="headerlink" title="查看某次commit的内容"></a>查看某次commit的内容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git show commitId</span></span><br></pre></td></tr></table></figure><h3 id="查看目录的diff信息"><a href="#查看目录的diff信息" class="headerlink" title="查看目录的diff信息"></a>查看目录的diff信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff &lt;dir-name&gt;</span></span><br></pre></td></tr></table></figure><h3 id="diff迁移"><a href="#diff迁移" class="headerlink" title="diff迁移"></a>diff迁移</h3><figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git diff &gt; diff.patch</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git apply --<span class="built_in">stat</span> diff.patch</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git apply --check diff.patch</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git apply diff.patch</span></span><br></pre></td></tr></table></figure><h3 id="查看log的其他信息"><a href="#查看log的其他信息" class="headerlink" title="查看log的其他信息"></a>查看log的其他信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --no-pager log -2 --author=&quot;HQ&quot; --pretty=format:&quot;%h&quot;</span><br></pre></td></tr></table></figure><h3 id="查看分支合并图"><a href="#查看分支合并图" class="headerlink" title="查看分支合并图"></a>查看分支合并图</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --graph</span></span><br></pre></td></tr></table></figure><h3 id="查看标签信息"><a href="#查看标签信息" class="headerlink" title="查看标签信息"></a>查看标签信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git show &lt;tag-name&gt;</span></span><br></pre></td></tr></table></figure><h3 id="查看git命令操作历史"><a href="#查看git命令操作历史" class="headerlink" title="查看git命令操作历史"></a>查看git命令操作历史</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br></pre></td></tr></table></figure><h3 id="git-rebase发生冲突怎么办"><a href="#git-rebase发生冲突怎么办" class="headerlink" title="git rebase发生冲突怎么办"></a>git rebase发生冲突怎么办</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rebase --skip  <span class="comment"># 抛弃本地的 commit，采用远程的 commit。慎用：因为你本地的修改都会失去</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rebase --abort <span class="comment"># 终止此次 rebase 操作</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rebase --<span class="built_in">continue</span> <span class="comment"># 手动处理冲突的文件：执行git add .，再 git rebase --continue，反复操作直到解决完所有冲突，并合并到分支上。</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切记，整个rebase解决冲突的过程中，都不需要自己去单独执行commit动作</span></span><br></pre></td></tr></table></figure><h3 id="删除本地认证"><a href="#删除本地认证" class="headerlink" title="删除本地认证"></a>删除本地认证</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global --<span class="built_in">unset</span> credential.helper</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config credential.helper store  <span class="comment"># window的可能需要手动找到git的凭证删掉，见下图</span></span></span><br></pre></td></tr></table></figure><p><img data-src="git_identity.png"></p><h3 id="HTTP认证方式更改为SSH"><a href="#HTTP认证方式更改为SSH" class="headerlink" title="HTTP认证方式更改为SSH"></a>HTTP认证方式更改为SSH</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global url.ssh://git@github.com/.insteadOf https://github.com/</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行上述命令后，可以查看下全局的.gitconfig配置如下：</span></span><br><span class="line">[url &quot;ssh://git@gitlab.sss.com/&quot;]</span><br><span class="line">insteadOf = https://gitlab.sss.com/</span><br><span class="line">[url &quot;ssh://git@pkg.sss.com/&quot;]</span><br><span class="line">insteadOf = https://pkg.sss.com/</span><br><span class="line">[http]</span><br><span class="line">sslVerify = false</span><br><span class="line">[url &quot;ssh://git@github.com/&quot;]</span><br><span class="line">insteadOf = https://github.com/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 完成替换后，记得添加ssh public key到gitlab profile配置里</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除本地认证</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global --<span class="built_in">unset</span> credential.helper</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置记住密码（默认15分钟）：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global credential.helper cache</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果想自己设置时间，可以这样做</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config credential.helper <span class="string">&#x27;cache --timeout=3600&#x27;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 永久存储密码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global credential.helper store</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://HQ1363.github.io/categories/Git/">Git</category>
      
      
      <category domain="http://HQ1363.github.io/tags/git/">git</category>
      
      
      <comments>http://hq1363.github.io/2021/08/02/git-ops/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>gitlab维护指南</title>
      <link>http://hq1363.github.io/2021/08/02/gitlab-ctl/</link>
      <guid>http://hq1363.github.io/2021/08/02/gitlab-ctl/</guid>
      <pubDate>Mon, 02 Aug 2021 06:36:50 GMT</pubDate>
      
      <description>gitlab部署、日常维护、常见问题解决方式.</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h2><h3 id="彻底卸载gitlab"><a href="#彻底卸载gitlab" class="headerlink" title="彻底卸载gitlab"></a>彻底卸载gitlab</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo gitlab-ctl stop</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo gitlab-ctl uninstall</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo gitlab-ctl cleanse</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo rm -rf /opt/gitlab</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 可通过`sudo gitlab-ctl <span class="built_in">help</span>`来获取相关命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo gitlab-ctl uninstall，关于其的说明是</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Kill all processes and uninstall the process supervisor (data will be preserved).</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 但在实际操作中，只通过uninstall无法彻底卸载gitlab</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sudo gitlab-ctl reconfigure</span></span><br></pre></td></tr></table></figure><h3 id="重载配置文件"><a href="#重载配置文件" class="headerlink" title="重载配置文件"></a>重载配置文件</h3><p><code>gitlab-ctl reconfigure</code></p><h3 id="启动所有-gitlab-组件"><a href="#启动所有-gitlab-组件" class="headerlink" title="启动所有 gitlab 组件"></a>启动所有 gitlab 组件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gitlab-ctl start         <span class="comment"># 启动所有服务</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gitlab-ctl start unicorn <span class="comment"># 启动单个服务</span></span></span><br></pre></td></tr></table></figure><h3 id="停止所有-gitlab-组件"><a href="#停止所有-gitlab-组件" class="headerlink" title="停止所有 gitlab 组件"></a>停止所有 gitlab 组件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gitlab-ctl stop          <span class="comment"># 停止所有服务</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gitlab-ctl stop unicorn  <span class="comment"># 停止单个服务</span></span></span><br></pre></td></tr></table></figure><h3 id="重启所有-gitlab-组件"><a href="#重启所有-gitlab-组件" class="headerlink" title="重启所有 gitlab 组件"></a>重启所有 gitlab 组件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gitlab-ctl restart         <span class="comment"># 重启所有服务</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gitlab-ctl restart unicorn <span class="comment"># 重启单个服务</span></span></span><br></pre></td></tr></table></figure><h3 id="查看服务的活动日志"><a href="#查看服务的活动日志" class="headerlink" title="查看服务的活动日志"></a>查看服务的活动日志</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gitlab-ctl tail         <span class="comment"># 查看所有服务的活动日志</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gitlab-ctl tail unicorn <span class="comment"># 查看单个服务的活动日志</span></span></span><br></pre></td></tr></table></figure><h3 id="查看服务状态"><a href="#查看服务状态" class="headerlink" title="查看服务状态"></a>查看服务状态</h3><p><code>gitlab-ctl status</code></p>]]></content:encoded>
      
      
      <category domain="http://HQ1363.github.io/categories/Git/">Git</category>
      
      
      <category domain="http://HQ1363.github.io/tags/git/">git</category>
      
      
      <comments>http://hq1363.github.io/2021/08/02/gitlab-ctl/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>聊聊持续集成</title>
      <link>http://hq1363.github.io/2021/07/31/continuous-integration/</link>
      <guid>http://hq1363.github.io/2021/07/31/continuous-integration/</guid>
      <pubDate>Sat, 31 Jul 2021 16:02:15 GMT</pubDate>
      
      <description>持续集成，简称`CI`，也不是一个新概念了；早在极限编程(XP)中，便作为12种实践之一被提出。最近三四年，随着`DevOps`概念逐渐被重视，`CI/CD`也成了市面上津津乐道的一个东西；然而也就是这么一个东西，即使每个公司都有着自己的实践方案，也仍然被其内部员工不停吐槽，这其中有很多原因，本文将会提到一部分；同时本文也将从多个角度，反复推敲`CI`，欢迎大佬们驻足留言，谢谢～</description>
      
      
      
      <content:encoded><![CDATA[<blockquote><p>持续集成，简称<code>CI</code>，也不是一个新概念了；早在极限编程(XP)中，便作为12种实践之一被提出。最近三四年，随着<code>DevOps</code>概念逐渐被重视，<code>CI/CD</code>也成了市面上津津乐道的一个东西；然而也就是这么一个东西，即使每个公司都有着自己的实践方案，也仍然被其内部员工不停吐槽，这其中有很多原因，本文将会提到一部分；同时本文也将从多个角度，反复推敲<code>CI</code>，欢迎大佬们驻足留言，谢谢～</p></blockquote><h2 id="暖场热身"><a href="#暖场热身" class="headerlink" title="暖场热身"></a>暖场热身</h2><p><strong><span style="color: blue">Q1</span>：你知道什么是<code>CI</code>吗？</strong><br><em>我相信很多人都听过CI，当我问出这个问题的时候，估计有人就会说了，这谁不知道啊，不就是<code>Continuous integration</code>嘛，整的好像谁不知道似的；紧接着，我要问了，那什么是<code>Continuous integration</code>呢。曾经我问过好几个开发朋友，他们也表示只知道字面意思，平时的工作”好像”也和CI没什么关系，应该指的就是打包、构建吧！！！</em></p><p><strong><span style="color: blue">Q2</span>: 你知道为啥需要<code>CI</code>吗？</strong><br><em>可能有的开发会说，我不需要，这东西浪费我开发时间，我只想专心写代码，现在整的一堆麻烦事，严重影响我的开发效率，真的是搞事情！！！</em></p><p><strong><span style="color: blue">Q3</span>: 你知道作为一名<code>Dev/Qa</code>，需要关注<code>CI</code>的哪些东西呢？</strong><br><em>只知道死干活的人，可能根本就不会去思考这类问题；说来也奇怪，往往是那些喜欢偷懒的人，懂得变通，可以想尽一切办法去偷懒。</em></p><p><strong><span style="color: blue">Q4</span>: 你知道大厂的CI都是怎么玩的吗？</strong><br><em>诚然，即便在业界已经有众多开源解决方案的今天，当结合到每家公司的不同场景下，往往会呈现出不同的效应；每家公司的发展阶段和侧重点是不一样的，其所需要落地的目标也是不尽相同的；特别是在一家快速发展的公司，你会发现其<code>CI</code>流程也是在逐渐变化，不停发展演进的。这也就意味着，在设计<code>CI</code>的时候，你需要充分考虑后期的可扩展性、可维护性、以及健壮性；以避免后期出现大规模的改动。</em></p><p><strong><span style="color: blue">Q5</span>: 倘若让你去设计CI流程，你会如何设计？</strong><br><em>一个好的CI流程，将会让开发团队极大受益，不仅能尽早地发现问题，还能维持高效、稳定、安全的业务迭代速度。</em></p><hr><p>在介绍持续集成之前，我想先介绍下传统的开发过程下的坑：</p><ul><li>BUG总是很晚才被发现，并且难以修复</li><li>研发交付质量无法得到保障</li><li>变更频繁，研发效率低下</li><li>重复性劳动，无效等待过多，用户满意度低</li></ul><p>如果你经历过或正在经历传统开发模式的伤与痛，你是否用过/想过：</p><ul><li>什么时候可以不用再为开发/测试环境而苦恼</li><li>什么时候可以不用再麻烦运维帮忙调试环境</li><li>什么时候可以不用手动测试，自动帮我测试</li><li>什么时候可以只专注于代码的开发</li></ul><blockquote><p>既然如此，我们话不多说，一起来了解一下<code>CI</code>吧；当然了，如果是大佬，我这就班门弄斧了，还望大佬们批评指正。</p></blockquote><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul><li>持续：意为长期、频繁不断地</li><li>集成：将一些孤立的事物或者元素通过某种方式联系在一起，从而构成一个有机整体的过程</li></ul><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>是一种通过在应用开发阶段引入自动化来频繁向客户交付应用的方法</li><li>是一种软件开发实践，项目成员能够频繁地进行集成，并通过自动化方式来尽快发现问题</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>需要有代码托管工具支持，如：<a href="https://github.com/">github</a>、<a href="https://gitee.com/">gitee</a></li><li>需要有专门的集成服务器来执行集成构建，如：<a href="https://www.jenkins.io/zh/">Jenkins</a>、<a href="https://circleci.com/">CircleCI</a>、<a href="https://travis-ci.com/">TravisCI</a></li><li>它是一个自动化的周期性集成测试过程，从检出代码、编译构建、运行测试、结果记录、测试统计等都是自动完成的，无需人工干预</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>可以提高软件开发和交付过程的透明度和洞察力</li><li>有效减少重复过程，节省时间、成本和工作量，完全自动化，利于尽早发现问题</li><li>可以帮助开发人员更加频繁地（有时甚至每天）将代码变更合并到共享分支或“主干”中</li></ul><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ul><li>就是让产品可以快速迭代，同时还能保持高质量；即：高效率、高质量、高产出。</li></ul><p>以上仅代表个人对<code>CI</code>的理解，关于基础概念这一块，可详细读一读<a href="https://www.cnblogs.com/davenkin/archive/2012/02/25/continuous-integration-from-martin-fowler.html">「Martin Fowler的持续集成」</a></p><hr><h2 id="组成模块"><a href="#组成模块" class="headerlink" title="组成模块"></a>组成模块</h2><h3 id="仓库管理"><a href="#仓库管理" class="headerlink" title="仓库管理"></a>仓库管理</h3><blockquote><p>一个好的仓库管理方式，在很多程度上，决定了研发之间的沟通协作方式；虽然是老生常谈的话题，但这个环节确实有必要拿出来捋一捋。到底是选择<code>mono repo</code>还是<code>multi repo</code>呢？我们来看看这其中的优缺点：</p></blockquote><ul><li><code>mono repo</code><br>也就是常说的<strong>单体仓库</strong>（大仓模式），它是将所有的服务，全部放到一个代码库，包含了每个业务的服务代码和公共的<code>Lib</code>库、<code>Tools</code>集合；既然代码都放到一起，也就很好管理了，带来的好处也不少，比如：<ul><li>易于开发者测试</li><li>易于标准化代码</li><li>易于开展Code Review</li><li>易于共享公共组件，避免重复造轮子</li><li>易于重构</li></ul></li><li><code>multi repo</code><br>和单体仓库相反，为<strong>多仓库</strong>方式（小仓模式）；每个服务代码单独成库，各自为营，彼此之间，井水不犯河水，做了很好的隔离。也就说多仓库具备如下特点：<ul><li>服务之间职责划分清晰</li><li>易于扩展，服务之间的解耦</li><li>限制clone范围，避免代码库完全泄漏</li></ul></li></ul><p>可以发现，<code>mono repo</code>的优点恰恰是<code>multi repo</code>的缺点，两者之间是互斥的关系；中小型的企业，一般用的是单体仓库，大型企业往往是多仓库；如果单论优点的个数，貌似mono repo确实更好一些，但其实也有一些大公司，用的是单体仓库，如：<code>Google</code>、<code>Facebook</code>、<code>Salesforce</code>.</p><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><blockquote><p>但凡提交过代码，就一定会涉及到分支，至少也会有一个<code>master</code>默认分支；如果你是一个优秀的<strong style="color: orange">Coder</strong>，在分支使用上，必然有一定的讲究，比如<u>分支的命名、分支的存活周期</u>上。业内有很多的分支管理方法，包括著名的<strong style="color: blue">GitFlow</strong>、<strong style="color: blue">TBD</strong>以及从他们衍生出来的版本。</p></blockquote><p><img data-src="git_flow.png" alt="git_flow.png"></p><ul><li><code>feature</code>分支：具体要开发的功能的分支，完成后合并到develop</li><li><code>develop</code>分支：开发的主分支，feature和release分支会基于此分支</li><li><code>release</code>分支：用于发布新版本的分支，完成后合并到develop和master</li><li><code>hotfix</code>分支：用于紧急修复已发布的产品问题的分支，完成后合并到develop和master</li><li><code>master</code>分支：与产品环境代码保持一致的分支，也就是每次发布完成之后发布的功能分支就要合并于此，以保持master更新</li></ul><p><strong>持续集成</strong>往往会基于分支做逻辑，不同的分支往往代表了研发的不同阶段；<u>合并分支的过程，其实就是一次代码集成的过程</u>；一个好的分支策略，不仅能使研发养成良好的开发习惯，还能加大持续集成发现问题的可能性。</p><h3 id="代码质量"><a href="#代码质量" class="headerlink" title="代码质量"></a>代码质量</h3><blockquote><p>当然了，持续集成，最关心的当属<strong style="color: orange">代码质量</strong>这一块了；而在代码质量评估这个环节，可以做的事情很多，但却很难发现所有的问题，只能说尽可能地、尽快地去发现问题。<span style="color: blue">Martin Fowler</span>曾说过，”<u>持续集成并不能消除Bug，而是让它们非常容易发现和改正</u>“。</p></blockquote><ul><li><p><code>编译构建</code><br>这个是肯定的，提交的代码如果编译都没法完成，下面的几步，根本没必要进行。有些公司，可能还会包含打包构建出产物的环节，但这属于持续交付，不应纳入持续集成环节。</p></li><li><p><code>代码评审</code><br>很多时候，我们会「因时间不够，需要急着上线」抑或是「代码太多，看不过来，也不想看」等原因不去<code>Code Review</code>。然而实际上，编写可维护代码的秘诀之一便是<code>Code Review</code>。这绝对不是一件易事，即便是Google，也花了很大的篇幅才说清楚他们在这一块的实践，感兴趣的朋友，可以来<a href="https://github.com/google/eng-practices/blob/master/review/reviewer/index.md"><span style="color: orange">这里</span></a>看看。很多代码管理平台，都自带了<code>code review</code>的特性，如<code>github</code>/<code>gitlab</code>/<code>gitee</code>等，也有对这一块做补充的Gerrit工具；前段时间，在<code>github</code>上看到了一个叫<code>ReviewDog</code>的产品，可以做到一些简单的自动化<code>review</code>工作，真感觉是个神器啊，必须respect一把。</p></li><li><p><code>持续测试</code><br>做到快速重复自动的测试，持续评估代码质量；这个过程主要是为了发现bug，确保主逻辑能走通；能做的测试很多，例如：</p><ul><li>单元测试：依赖于研发和QA及时编写和更新测试用例</li><li>集成测试：多feature同时上线时的多功能测试阶段</li><li>性能测试：服务接口上线前的压力测试</li></ul></li><li><p><code>代码分析</code><br>可以做的<strong>lint</strong>检测很多，市面上也有很多工具平台，包括但不限于<u><span style="color: orange">SonarQube</span></u>、<u><span style="color: orange">TeskLink</span></u>、<u><span style="color: orange">FindBugs</span></u>、<u><span style="color: orange">CheckStyles</span></u>等。除了这些，我们可能还会做安全漏洞扫描，以及自定义的lint检测任务。</p></li></ul><hr><h2 id="设计实现"><a href="#设计实现" class="headerlink" title="设计实现"></a>设计实现</h2><p>终于来到了，大伙儿最关心的设计实现环节；其实，实现持续集成的过程，就是将上述组成模块拼接到一块，形成自动化的流水线；而一套<code>CI</code>的设计与实现，往往跟一家公司的规模、发展阶段、以及所使用的技术栈紧密相关，当然也可能包含有很重的历史包袱，这里给出几个范例，具体还需要大伙儿结合自身场景出发。</p><h3 id="典型场景"><a href="#典型场景" class="headerlink" title="典型场景"></a>典型场景</h3><p><img data-src="classic_case.png" alt="典型场景"></p><h3 id="微服务场景"><a href="#微服务场景" class="headerlink" title="微服务场景"></a>微服务场景</h3><p><img data-src="microservice_case.png" alt="微服务场景"></p><h3 id="Cloud-Native"><a href="#Cloud-Native" class="headerlink" title="Cloud Native"></a><a href="https://github.com/kubernetes/test-infra/tree/master/prow">Cloud Native</a></h3><p><img data-src="cloud_native.png" alt="云原生"><br>其实总的来说，也就那么两条路子，要么自研、要么使用开源版；有能力和时间的公司，往往会选择自研，毕竟开源版，很多功能都是受限的，也无法很好地融入到企业技术栈，需要深度定制；所以你会发现，基于开源版二次开发，往往是大部分公司的路子。</p><h2 id="参考案例"><a href="#参考案例" class="headerlink" title="参考案例"></a>参考案例</h2><h3 id="满帮"><a href="#满帮" class="headerlink" title="满帮"></a>满帮</h3><blockquote><p>满帮由运满满+货车帮合并而来，技术栈也是融合了1-2年，CI/CD一块最终沿用了运满满的一套体系，而运满满的体系源自早期滴滴的一套体系。</p></blockquote><p>满帮的<code>CI</code>是测试团队负责的，每次打包构建都是用户手动触发的，可以节省资源，降低成本，避免无用的构建任务；<u>测试会在<code>Jenkins</code>构建的生命周期上做自己的逻辑，一旦构建过程中，发现问题，会去统计，并反馈到各个研发团队</u>。研发团队用的也是小仓文化，采用的分支比较简单，feature分支+master分支，无论哪一个分支，都需要在qa环境（等价于ppe/pre预发环境）部署测试通过，然后由测试老师进行线上的部署动作。环境的划分是dev/qa/prod，每个环境下，又会有不同的机房、不同的k8s甬道，研发通常会在dev的不同甬道下做自己的业务测试。</p><h3 id="饿了么"><a href="#饿了么" class="headerlink" title="饿了么"></a>饿了么</h3><blockquote><p>如果你对饿了么有一定了解，想必你也知道，饿了么的业务线（外卖、物流、商户、新零售、开放平台等）非常多，光<span style="color: orange">AppID</span>（应用服务标示）就多达上千（小仓模式），而这些业务往往需要快速迭代，很多时候的需求都是倒排期，各种CR需求也是常有的事情，加班也是出了名的；可想而知，饿了么每天的持续集成任务量，得有多大，不禁让人好奇饿了么的<strong>持续集成</strong>是如何设计实现的。</p></blockquote><p>饿了么的持续集成，经历了三代的发展（<span style="color: orange">Eless</span> -&gt; <span style="color: orange">ElessV2/APPOS</span> -&gt; <span style="color: orange">AONE</span>）；<span style="color: orange">AONE</span>是饿了么融入阿里体系后，使用的方案，这个没办法，集团内技术栈打通并统一是肯定的趋势。每个版本的UI我也记得不是很清楚了，下面的图仅为作者印象还原样子，不喜勿喷！！！<br><img data-src="eless_v1.png" alt="ELESS初代目"><div style="color: blue">初代目是基于Jenkins玩的，根据每个仓库的语言类别，执行Jenkins上对应的Job任务(例如：ci-python-job/ci-java-job)，每个Job任务，会根据仓库根目录下的CI YAML(类同gitlab-ci.yaml/travis-ci.yaml)完成编译构建之外的CI环节。</div></p><p><img data-src="eless_v2.png" alt="ELESS二代目"><div style="color: blue">二代目去掉了Jenkins，因为Jenkins很容易出现任务堆积；虽说饿了么当时的Jenkins集群，node节点有十几台，但也还是会出现堆积等待的情况，成本也是一个问题，索性自研实现了jenkins环节。但无论是一代目还是二代目，只要有新的commit触发，便会触发新的构建任务，环境划分也是一致的。二代目，不过是在一代目的基础上，做了改进和优化，整个CI没有太大的变化。</div></p><h4 id="环境划分"><a href="#环境划分" class="headerlink" title="环境划分"></a>环境划分</h4><ul><li>alpha环境：开发自测环境</li><li>beta环境：qa测试环境</li><li>ppe/vip环境：预发环境，几乎等同于线上，仅允许办公网用户测试</li><li>prod环境</li></ul><p>不过当时的环境存在很严重的资源互斥使用问题，多个研发的需求，没办法同时测试；A开发将自己的代码发布到alpha环境后，B开发如果也想在alpha环境测试，就只能把A开发的代码覆盖掉，这个是有问题的，整个请求链路无法自由调整。虽然每个服务所在的集群有自己的SOA Cluster名，可以在服务注册中心中，修改上游服务调用的Cluster名，做到测试的目的，但依旧不能同时测试多人的开发需求。其实完全，可以根据前端传入不同Header、或者动态域名来做请求链路区分的。</p><h4 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h4><p><span style="color: orange">Eless</span>在分支上并未做特殊的限制，整体上和git flow是一致的，发布的时候，也没有锁分支（仅限<code>release</code>分支），也就是说，任何一个分支都可以发布到线上，只不过每一个分支下的<code>commit</code>，必须是上一个环境发布测试通过后，手动点击<code>test pass</code>，才可以发到下一个环境；当准备<code>ppe</code> -&gt; <code>prod</code>时，需要测试负责人点通过，才可以发布<code>prod</code>。使用<span style="color: orange">AONE</span>后，可以做集成测试，多个开发分支，会合并到一个集成测试分支下，用作多需求同时测试，这个过程会遭遇频繁地解决冲突，用起来也是够呛（😓）；不过冲突只是提早被发现了，这个过程无法避免。AoneFlow只有feature、release、master三类分支，但你却能看到其他分支模式的影子；它基本上兼顾了 TrunkBased 的“易于持续集成”和 GitFlow 的“易于管理需求”特点，同时规避掉 GitFlow 的那些繁文缛节。不过AONE平台集成了<u>在线解决冲突</u>、<u>在线Code Review</u>、<u>发布完毕自动合并release分支到master分支</u>的优点，可以保证线上的包都经过了所有环境的验证。<br><img data-src="waimai_branch.png" alt="Eless分支策略"></p><blockquote><p>不同研发团队，可能会有所差别，具体看团队怎么玩。</p></blockquote><h3 id="哔哩哔哩"><a href="#哔哩哔哩" class="headerlink" title="哔哩哔哩"></a>哔哩哔哩</h3><blockquote><p>无论是饿了么，还是满帮，CI过程都脱离了<span style="color: orange">研发场景</span>，或者说比较简单；<u>B站的CI和研发绑定的尤为密切，整个CI过程，围绕PR的生命周期来，只要CI（各种各样的Lint检测任务）不通过，就不让合入代码</u>。不过有一点确实挺好奇，B站后端的CI和CD是完全割裂的，没有串起来，形成流水线。</p></blockquote><p>B站的研发测试环境，主要依赖于服务节点染色的概念，和k8s甬道（给pod打标签）的方式是类似的，不过B站每个染色节点都是单独可测的，上下游请求链路完全打通，也就是说：它满足了多需求可以同时测试。</p><p>细心的朋友，可能会发现，上述的三个案例，正好是「第四点」说的三种设计实现方式。</p><h3 id="阿里巴巴"><a href="#阿里巴巴" class="headerlink" title="阿里巴巴"></a>阿里巴巴</h3><p><img data-src="ali_cloud.png" alt="阿里云效"></p><h3 id="腾讯Coding"><a href="#腾讯Coding" class="headerlink" title="腾讯Coding"></a>腾讯Coding</h3><p><img data-src="tencent_coding.png" alt="腾讯Coding"></p><p>不难发现，无论是阿里、腾讯，还是百度，他们的CI设计都是和CD完全串起来的，而且没有脱离研发场景。但是也不难发现，这三家公司的设计，大体都长一个样子，你懂我的意思吧（😂）。</p>]]></content:encoded>
      
      
      <category domain="http://HQ1363.github.io/categories/CI/">CI</category>
      
      
      <category domain="http://HQ1363.github.io/tags/CI/">CI</category>
      
      
      <comments>http://hq1363.github.io/2021/07/31/continuous-integration/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
