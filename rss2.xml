<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>春暖花开</title>
    <link>http://HQ1363.github.io/</link>
    
    <atom:link href="http://hq1363.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>这一路收获的不只是美丽的风景, 还有一份厚重充实、满满幸福的乐观豁达心情</description>
    <pubDate>Sat, 27 Jan 2024 12:19:21 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>运维实践指南</title>
      <link>http://hq1363.github.io/2024/01/27/linux/</link>
      <guid>http://hq1363.github.io/2024/01/27/linux/</guid>
      <pubDate>Sat, 27 Jan 2024 06:36:50 GMT</pubDate>
      
      <description>无论你是开发，还是运维，亦或者是测试，免不了要和系统打交道，而linux系统通常也是我们线上服务的部署系统，掌握一些必备的运维知识，能让你如鱼得水.</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="远端服务端口探测"><a href="#远端服务端口探测" class="headerlink" title="远端服务端口探测"></a>远端服务端口探测</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> nmap -p 80 example.com</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> telnet example.com 22</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> nc -zv example.com 443</span></span><br></pre></td></tr></table></figure><h2 id="检查ssh是否ready"><a href="#检查ssh是否ready" class="headerlink" title="检查ssh是否ready"></a>检查ssh是否ready</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -T git@example.com</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://HQ1363.github.io/categories/Linux/">Linux</category>
      
      
      <category domain="http://HQ1363.github.io/tags/linux/">linux</category>
      
      
      <comments>http://hq1363.github.io/2024/01/27/linux/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>go坑大勿踩</title>
      <link>http://hq1363.github.io/2023/12/09/go_pit/</link>
      <guid>http://hq1363.github.io/2023/12/09/go_pit/</guid>
      <pubDate>Sat, 09 Dec 2023 06:36:50 GMT</pubDate>
      
      <description>go作为高级程序设计语言，有其自身的独特性，但也会有容易踩坑的地方；下面将列举一些主要的场景，引以为鉴.</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="For循环内启动Goroutine问题"><a href="#For循环内启动Goroutine问题" class="headerlink" title="For循环内启动Goroutine问题"></a>For循环内启动Goroutine问题</h3><p>以下是一段很常见的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">envList := []<span class="keyword">string</span>&#123;<span class="string">&quot;dev&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;pre&quot;</span>, <span class="string">&quot;prod&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, env := <span class="keyword">range</span> envList &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Println(env)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的结果始终是prod，因为内部循环goroutine使用的变量一直是循环变量env，而env所代表的内存地址始终就只有一块，也就是说env只能是一个值，不可能代表不同的值。为了解决这个问题，我们需要开辟新的存储空间，来存放每一次的值。修改后的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">envList := []<span class="keyword">string</span>&#123;<span class="string">&quot;dev&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;pre&quot;</span>, <span class="string">&quot;prod&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, env := <span class="keyword">range</span> envList &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(envName <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">fmt.Println(envName)</span><br><span class="line">&#125;(env)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="For循环struct数组问题"><a href="#For循环struct数组问题" class="headerlink" title="For循环struct数组问题"></a>For循环struct数组问题</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> DD <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line">ddList := []DD&#123;</span><br><span class="line">&#123;</span><br><span class="line">Name: <span class="string">&quot;aaa&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Name: <span class="string">&quot;bbb&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Name: <span class="string">&quot;ccc&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> nameList []*DD</span><br><span class="line"><span class="keyword">for</span> _, dd := <span class="keyword">range</span> ddList &#123;</span><br><span class="line">nameList = <span class="built_in">append</span>(nameList, &amp;dd)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%+v&quot;</span>, nameList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的nameList里的，每一个元素都是一样的，指向同一片内存空间。因为你仍然是将循环对象的引用地址追加到nameList里去，所以肯定是相同的。为解决这个问题，应该如下操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> DD <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line">ddList := []DD&#123;</span><br><span class="line">&#123;</span><br><span class="line">Name: <span class="string">&quot;aaa&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Name: <span class="string">&quot;bbb&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Name: <span class="string">&quot;ccc&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> nameList []*DD</span><br><span class="line"><span class="keyword">for</span> _, dd := <span class="keyword">range</span> ddList &#123;</span><br><span class="line">tmpDD := dd    <span class="comment">// 也是通过申请新的存储空间来解决</span></span><br><span class="line">nameList = <span class="built_in">append</span>(nameList, &amp;tmpDD)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%+v&quot;</span>, nameList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是修改前的代码，如何使用的是指针数组，就不存在上述的问题，请思考下这是为什么，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> DD <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line">ddList := []*DD&#123;</span><br><span class="line">&#123;</span><br><span class="line">Name: <span class="string">&quot;aaa&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Name: <span class="string">&quot;bbb&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Name: <span class="string">&quot;ccc&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> nameList []*DD</span><br><span class="line"><span class="keyword">for</span> _, dd := <span class="keyword">range</span> ddList &#123;</span><br><span class="line">nameList = <span class="built_in">append</span>(nameList, dd)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%+v&quot;</span>, nameList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果修改前的代码里，ddList是基本数据类型，而nameList同样是指针数组，同样有一样的问题，代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ddList := []<span class="keyword">string</span>&#123;<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>, <span class="string">&quot;ccc&quot;</span>&#125;</span><br><span class="line"><span class="keyword">var</span> nameList []*<span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> _, dd := <span class="keyword">range</span> ddList &#123;</span><br><span class="line">nameList = <span class="built_in">append</span>(nameList, &amp;dd)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%+v&quot;</span>, nameList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述同样是由于使用循环变量dd的内存空间导致的，而这个内存空间的始终是固定不变的。如果最开始的代码，这样改，那也没问题：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">type</span> DD <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line">ddList := []DD&#123;</span><br><span class="line">&#123;</span><br><span class="line">Name: <span class="string">&quot;aaa&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Name: <span class="string">&quot;bbb&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">Name: <span class="string">&quot;ccc&quot;</span>,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> nameList []DD</span><br><span class="line"><span class="keyword">for</span> _, dd := <span class="keyword">range</span> ddList &#123;</span><br><span class="line">nameList = <span class="built_in">append</span>(nameList, dd)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%+v&quot;</span>, nameList) <span class="comment">// 每个值都是不一样的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有些人可能搞不明白了，为啥区别这么大呢，其实也能理解：for的循环变量始终是取值的操作逻辑，当ddList是指针数组时，那循环变量dd的值始终是循环的每一个地址，每一个都是不同的；如果ddList非指针数组，切记不能把他的指针传递给调用方，因为此时他值所在的内存地址始终是固定的，不会变。总计一句话：<strong>for循环非指针数组时，不可直接取地址给依赖方</strong></p>]]></content:encoded>
      
      
      <category domain="http://HQ1363.github.io/categories/Go/">Go</category>
      
      
      <category domain="http://HQ1363.github.io/tags/go/">go</category>
      
      
      <comments>http://hq1363.github.io/2023/12/09/go_pit/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>慢SQL优化实践</title>
      <link>http://hq1363.github.io/2023/11/11/slow-sql/</link>
      <guid>http://hq1363.github.io/2023/11/11/slow-sql/</guid>
      <pubDate>Sat, 11 Nov 2023 03:36:50 GMT</pubDate>
      
      <description>日常CRUD开发，经常遇到API耗时严重、慢SQL层出不穷的问题；本人在经过一个月的慢SQL斗争中，得到了一些经验，现汇总如下。</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="慢SQL优化实践"><a href="#慢SQL优化实践" class="headerlink" title="慢SQL优化实践"></a>慢SQL优化实践</h1>]]></content:encoded>
      
      
      <category domain="http://HQ1363.github.io/categories/MySQL/">MySQL</category>
      
      
      <category domain="http://HQ1363.github.io/tags/MySQL/">MySQL</category>
      
      <category domain="http://HQ1363.github.io/tags/SQL/">SQL</category>
      
      
      <comments>http://hq1363.github.io/2023/11/11/slow-sql/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>nginx配置实战</title>
      <link>http://hq1363.github.io/2023/06/24/nginx/</link>
      <guid>http://hq1363.github.io/2023/06/24/nginx/</guid>
      <pubDate>Sat, 24 Jun 2023 06:36:50 GMT</pubDate>
      
      <description>日常工作中，经常需要同nginx打交道；没有经验的情况下，配置起来很是鸡肋，无法达到想要的效果，这里列举一些常见的nginx应用场景的配置.</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="前端路由结合Nginx"><a href="#前端路由结合Nginx" class="headerlink" title="前端路由结合Nginx"></a>前端路由结合Nginx</h2><blockquote><p>如果你遇到 <a href="https://cdn.com/users/123">https://cdn.com/users/123</a> 刷新后 404 的问题，你需要按照这个章节进行处理。</p></blockquote><p>Ant Design Pro 使用的 Umi 支持两种路由方式：browserHistory 和 hashHistory。</p><p>可以在 config/config.js 中进行配置选择用哪个方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  history: &#x27;hash&#x27;, // 默认是 browser</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>hashHistory 使用如 <a href="https://cdn.com/#/users/123">https://cdn.com/#/users/123</a> 这样的 URL，取井号后面的字符作为路径。browserHistory 则直接使用 <a href="https://cdn.com/users/123">https://cdn.com/users/123</a> 这样的 URL。使用 hashHistory 时浏览器访问到的始终都是根目录下 index.html。使用 browserHistory 则需要服务器做好处理 URL 的准备，处理应用启动最初的 / 这样的请求应该没问题，但当用户来回跳转并在 /users/123 刷新时，服务器就会收到来自 /users/123 的请求，这时你需要配置服务器能处理这个 URL 返回正确的 index.html。强烈推荐使用默认的 browserHistory。<br>强烈推荐使用默认的 browserHistory.</p><p>nginx 作为最流行的 web 容器之一，配置和使用相当简单，只要简单的配置就能拥有高性能和高可用。推荐使用 nginx 托管。示例配置如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    # gzip config</span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_min_length 1k;</span><br><span class="line">    gzip_comp_level 9;</span><br><span class="line">    gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;</span><br><span class="line">    gzip_vary on;</span><br><span class="line">    gzip_disable &quot;MSIE [1-6]\.&quot;;</span><br><span class="line"></span><br><span class="line">    root /usr/share/nginx/html;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        # 用于配合 browserHistory使用</span><br><span class="line">        try_files $uri $uri/ /index.html;</span><br><span class="line"></span><br><span class="line">        # 如果有资源，建议使用 https + http2，配合按需加载可以获得更好的体验</span><br><span class="line">        # rewrite ^/(.*)$ https://preview.pro.ant.design/$1 permanent;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    location /api &#123;</span><br><span class="line">        proxy_pass https://preview.pro.ant.design;</span><br><span class="line">        proxy_set_header   X-Forwarded-Proto $scheme;</span><br><span class="line">        proxy_set_header   Host              $http_host;</span><br><span class="line">        proxy_set_header   X-Real-IP         $remote_addr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line"><span class="meta">  #</span><span class="bash"> 如果有资源，建议使用 https + http2，配合按需加载可以获得更好的体验</span></span><br><span class="line">  listen 443 ssl http2 default_server;</span><br><span class="line"></span><br><span class="line"><span class="meta">  #</span><span class="bash"> 证书的公私钥</span></span><br><span class="line">  ssl_certificate /path/to/public.crt;</span><br><span class="line">  ssl_certificate_key /path/to/private.key;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">        # 用于配合 browserHistory使用</span><br><span class="line">        try_files $uri $uri/ /index.html;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">  location /api &#123;</span><br><span class="line">      proxy_pass https://preview.pro.ant.design;</span><br><span class="line">      proxy_set_header   X-Forwarded-Proto $scheme;</span><br><span class="line">      proxy_set_header   Host              $http_host;</span><br><span class="line">      proxy_set_header   X-Real-IP         $remote_addr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    server backend1.example.com:8080 weight=3;</span><br><span class="line">    server backend2.example.com:8080;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name example.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://backend;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跨域配置"><a href="#跨域配置" class="headerlink" title="跨域配置"></a>跨域配置</h2><p>在标准的跨域请求中，Access-Control-Allow-Origin 头部只能包含单个域名或*。它指示浏览器允许哪些源（域名）进行跨域请求。<br>所以根据规范，Access-Control-Allow-Origin 不支持返回多个域名。如果需要允许多个域名进行跨域请求，您需要在后端服务器根据请求的 Origin 值进行逻辑判断，然后动态设置正确的 Access-Control-Allow-Origin 头部。<br>例如，在后端服务器代码中，可以根据请求头中的 Origin 判断是哪个域名发起的请求，然后设置相应的 Access-Control-Allow-Origin 头部值。<br>请注意，当在响应头中设置 Access-Control-Allow-Origin 为 * 时，表示允许任何源进行跨域请求。这是一种宽松的设置，适用于公开的 API，但对于一些需要更严格访问控制的场景，建议根据具体需求设置具体的域名。<br>总结来说，Access-Control-Allow-Origin 头部是单值的，不支持返回多个域名，但您可以根据你的后端逻辑设置合适的值。</p><blockquote><p>跨域配置有很多种写法，而且有其生效的作用域，具体视情况而定，这里列一些case：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">case</span> 1</span></span><br><span class="line">if ($request_method = OPTIONS) &#123;</span><br><span class="line">    return 200 &#x27;&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ($http_origin ~* (xx\.cn|yy\.zh)$) &#123;</span><br><span class="line">    set $cors &quot;true&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ($request_method = &#x27;OPTIONS&#x27;) &#123;</span><br><span class="line">    set $cors &quot;$&#123;cors&#125;options&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ($request_method = &#x27;GET&#x27;) &#123;</span><br><span class="line">    set $cors &quot;$&#123;cors&#125;get&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ($request_method = &#x27;POST&#x27;) &#123;</span><br><span class="line">    set $cors &quot;$&#123;cors&#125;post&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ($cors = &#x27;true&#x27;) &#123;</span><br><span class="line">    add_header &#x27;Access-Control-Allow-Origin&#x27; &quot;$http_origin&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ($cors = &quot;trueget&quot;) &#123;</span><br><span class="line">    add_header &#x27;Access-Control-Allow-Origin&#x27; &quot;$http_origin&quot;;</span><br><span class="line">    add_header &#x27;Access-Control-Allow-Credentials&#x27; &#x27;true&#x27;;</span><br><span class="line">    add_header &#x27;Access-Control-Allow-Methods&#x27; &#x27;GET, POST, PUT, DELETE, PATCH, OPTIONS&#x27;;</span><br><span class="line">    add_header &#x27;Access-Control-Allow-Headers&#x27; &#x27;Content-Type, X-System-USERID, X-System-RequestID&#x27;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">case</span> 2</span></span><br><span class="line">location / &#123;</span><br><span class="line">    # 允许跨域的请求，可以自定义变量$http_origin，*表示所有  </span><br><span class="line">    add_header &#x27;Access-Control-Allow-Origin&#x27; *;  </span><br><span class="line">    # 允许携带cookie请求  </span><br><span class="line">    add_header &#x27;Access-Control-Allow-Credentials&#x27; &#x27;true&#x27;;  </span><br><span class="line">    # 允许跨域请求的方法：GET,POST,OPTIONS,PUT  </span><br><span class="line">    add_header &#x27;Access-Control-Allow-Methods&#x27; &#x27;GET,POST,OPTIONS,PUT&#x27;;  </span><br><span class="line">    # 允许请求时携带的头部信息，*表示所有  </span><br><span class="line">    add_header &#x27;Access-Control-Allow-Headers&#x27; *;  </span><br><span class="line">    # 允许发送按段获取资源的请求  </span><br><span class="line">    add_header &#x27;Access-Control-Expose-Headers&#x27; &#x27;Content-Length,Content-Range&#x27;;  </span><br><span class="line">    # 一定要有！！！否则Post请求无法进行跨域！</span><br><span class="line">    # 在发送Post跨域请求前，会以Options方式发送预检请求，服务器接受时才会正式请求  </span><br><span class="line">    if ($request_method = &#x27;OPTIONS&#x27;) &#123;  </span><br><span class="line">        add_header &#x27;Access-Control-Max-Age&#x27; 1728000;  </span><br><span class="line">        add_header &#x27;Content-Type&#x27; &#x27;text/plain; charset=utf-8&#x27;;  </span><br><span class="line">        add_header &#x27;Content-Length&#x27; 0;  </span><br><span class="line">        # 对于Options方式的请求返回204，表示接受跨域请求  </span><br><span class="line">        return 204;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果因API返回了多层跨域配置，导致API无法调用通，需要将多个跨域配置，改为单个<br>当 API 的响应头中出现了多个 <code>Access-Control-Allow-Origin</code> 头部时，浏览器会视为无效的响应头，并拒绝处理跨域请求。为了解决这个问题，您可以采取下面的步骤：<br>确保后端 API 只返回一个 <code>Access-Control-Allow-Origin</code> 头部。在后端服务器的响应中，只设置一个允许跨域请求的源，而不是返回多个 <code>Access-Control-Allow-Origin</code> 头部。例如，将以下代码添加到后端服务器的响应中：<br>response.headers[‘Access-Control-Allow-Origin’] = ‘<a href="https://example.com&/#39;">https://example.com&#39;</a><br>如果后端服务器无法修复此问题，您可以使用 <code>Nginx</code> 来移除多余的 <code>Access-Control-Allow-Origin</code> 头部。示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">location &#x2F;api &#123;</span><br><span class="line">    proxy_pass http:&#x2F;&#x2F;backend;</span><br><span class="line">    proxy_hide_header Access-Control-Allow-Origin;</span><br><span class="line">    add_header Access-Control-Allow-Origin $http_origin always;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该配置中使用了 <code>proxy_hide_header</code> 指令来隐藏 <code>Access-Control-Allow-Origin</code> 头部，然后再使用 <code>add_header</code> 指令添加正确的 <code>Access-Control-Allow-Origin</code> 头部。<br>这样配置后，<code>Nginx</code> 会先隐藏原始的 <code>Access-Control-Allow-Origin</code> 头部，然后添加一个根据请求头中的 <code>Origin</code> 值动态生成的正确的 <code>Access-Control-Allow-Origin</code> 头部。<br>请注意，使用 <code>proxy_hide_header</code> 只是将该头部从响应头中隐藏，并不代表它不存在。因此，您仍然需要使用 <code>add_header</code> 指令添加正确的 <code>Access-Control-Allow-Origin</code> 头部。<br>用以上方法可以解决返回多个 <code>Access-Control-Allow-Origin</code> 头部的问题，并确保正确的跨域配置。</p><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    server backend1.example.com:8080;</span><br><span class="line">    server backend2.example.com:8080;</span><br><span class="line">    server backend3.example.com:8080;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name example.com;</span><br><span class="line">    location / &#123;</span><br><span class="line">    proxy_pass http://backend;</span><br><span class="line">    proxy_set_header Host $host;</span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="部署静态网站"><a href="#部署静态网站" class="headerlink" title="部署静态网站"></a>部署静态网站</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  example.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /images/ &#123;</span><br><span class="line">        alias /var/www/images/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location /downloads/ &#123;</span><br><span class="line">        alias /var/www/downloads/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="定制403-404页面"><a href="#定制403-404页面" class="headerlink" title="定制403/404页面"></a>定制403/404页面</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> nginx http模块加入如下配置</span></span><br><span class="line">fastcgi_intercept_errors on;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在server模块加入如下配置</span></span><br><span class="line">location / &#123;</span><br><span class="line">    root   /data;</span><br><span class="line">    index  index.html index.htm yunmai.html;</span><br><span class="line">    error_page   403  /403.html;</span><br><span class="line">    error_page   404  /404.html;</span><br><span class="line">    location = /403.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">    location = /404.html &#123;</span><br><span class="line">        root   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WebSocket服务器"><a href="#WebSocket服务器" class="headerlink" title="WebSocket服务器"></a>WebSocket服务器</h2><p>在使用Nginx作为WebSocket服务器时，Nginx会将客户端请求转发到后端的WebSocket服务器上，并实现WebSocket协议的连接管理。这种场景通常用于实时通信、游戏等应用程序。下面是一个示例Nginx配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">map $http_upgrade $connection_upgrade &#123;</span><br><span class="line">    default upgrade;</span><br><span class="line">    &#x27;&#x27; close;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name example.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://backend;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">        proxy_set_header Connection $connection_upgrade;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述配置中，Nginx会将WebSocket请求转发到<a href="http://backend上,并设置http头信息中的upgrade、connection、host和x-real-ip字段,从而实现websocket协议的连接管理./">http://backend上，并设置HTTP头信息中的Upgrade、Connection、Host和X-Real-IP字段，从而实现WebSocket协议的连接管理。</a></p><h2 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h2><p>动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">upstream test&#123;  </span><br><span class="line">       server localhost:;  </span><br><span class="line">       server localhost:;  </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    server &#123;  </span><br><span class="line">        listen       ;  </span><br><span class="line">        server_name  localhost;  </span><br><span class="line"></span><br><span class="line">        location / &#123;  </span><br><span class="line">            root   e:\wwwroot;  </span><br><span class="line">            index  index.html;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        # 所有静态请求都由nginx处理，存放目录为html  </span><br><span class="line">        location ~ \.(gif|jpg|jpeg|png|bmp|swf|css|js)$ &#123;  </span><br><span class="line">            root    e:\wwwroot;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        # 所有动态请求都转发给tomcat处理  </span><br><span class="line">        location ~ \.(jsp|do)$ &#123;  </span><br><span class="line">            proxy_pass  http://test;  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        error_page        /50x.html;  </span><br><span class="line">        location = /50x.html &#123;  </span><br><span class="line">            root   e:\wwwroot;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以吧HTML以及图片和css以及js放到wwwroot目录下，而tomcat只负责处理jsp和请求，例如当我们后缀为gif的时候，Nginx默认会从wwwroot获取到当前请求的动态图文件返回，当然这里的静态文件跟Nginx是同一台服务器，我们也可以在另外一台服务器，然后通过反向代理和负载均衡配置过去就好了，只要搞清楚了最基本的流程，很多配置就很简单了，另外localtion后面其实是一个正则表达式，所以非常灵活</p><h2 id="防盗链"><a href="#防盗链" class="headerlink" title="防盗链"></a>防盗链</h2><blockquote><p>盗链：比如我们线上的图片等静态资源，经常会被其他网站盗用，他们发大财的同时，成本确实我们在买单，这就很可恶。一些名不见经传的小网站来盗取一些有实力的大网站的地址（比如一些音乐、图片、软件的下载地址）然后放置在自己的网站中，通过这种方法盗取大网站的空间和流量。直接在自己的网站上向最终用户提供其它服务提供商的服务内容，骗取最终用户的浏览和点击率。受益者不提供资源或提供很少的资源，而真正的服务提供商却得不到任何的收益。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在项目中,经常会有不想让本站点的静态资源被他人盗取访问的需求,比如网站中的图片,前端加载的一些js文件等,此时就可以配置nginx的防盗链来实现网站资源的防盗。</span></span><br><span class="line">server &#123;</span><br><span class="line">    location ~ .*\.(txt|xml)$ &#123;</span><br><span class="line">        # 配置防盗链规则</span><br><span class="line">        valid_referers none blocked 192.168.1.110 *.example.com example.* ~\.google\.;</span><br><span class="line">        # 如果不符合防盗链规则，则返回403</span><br><span class="line">        if ($invalid_referer) &#123;</span><br><span class="line">            return 403;</span><br><span class="line">        &#125;</span><br><span class="line">        root /vagrant/doc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="https强跳"><a href="#https强跳" class="headerlink" title="https强跳"></a>https强跳</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set $rewrite_status 0;</span><br><span class="line">if ($https_status = off) &#123; set $rewrite_status &quot;$&#123;rewrite_status&#125;1&quot;; &#125;</span><br><span class="line">if ($scheme = http) &#123; set $rewrite_status &quot;$&#123;rewrite_status&#125;2&quot;; &#125;</span><br><span class="line">if ($uri !~ &#x27;^/test&#x27;) &#123; set $rewrite_status &quot;$&#123;rewrite_status&#125;3&quot;; &#125;</span><br><span class="line">if ($https = on) &#123; set $https_status $https; &#125;</span><br><span class="line">if ($rewrite_status = 0123) &#123;</span><br><span class="line">   rewrite / https://$host$uri permanent;</span><br><span class="line">   break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rewrite案例"><a href="#rewrite案例" class="headerlink" title="rewrite案例"></a>rewrite案例</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">case</span> 1</span></span><br><span class="line">location ~ ^/backend/(.*) &#123;</span><br><span class="line">  proxy_set_header X-Forwarded-For $x_real_ip;</span><br><span class="line">  proxy_set_header Host xxxx.test.com;</span><br><span class="line">  proxy_http_version 1.1;</span><br><span class="line">  proxy_set_header Connection &quot;&quot;;</span><br><span class="line">  rewrite /backend/(.*) /$1 break;</span><br><span class="line">  proxy_pass http://web.loop;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">case</span> 2</span></span><br><span class="line">location /goods &#123;  #判断商品的路径</span><br><span class="line"><span class="meta">  #</span><span class="bash">&#123;1,5&#125; 表示1-5位的数字</span></span><br><span class="line"><span class="meta">  #</span><span class="bash">商品为goods-121.html</span></span><br><span class="line">  rewrite &quot;goods-(\d&#123;1,5&#125;)\.html&quot; /goods-ctrl.html?id=$(1);</span><br><span class="line"><span class="meta">  #</span><span class="bash">路径</span></span><br><span class="line">  root yellowcong.com;</span><br><span class="line"><span class="meta">  #</span><span class="bash">页面</span></span><br><span class="line">  index index.html;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">case</span> 3</span></span><br><span class="line">location ~ ^/api/([0-9]+)(\.[0-9]+)*/client/ &#123;</span><br><span class="line">    rewrite /(.*)$ /$1 break;</span><br><span class="line">    proxy_pass http://bbb.example.com;</span><br><span class="line">    proxy_set_header Host $proxy_host;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将<code>/info/22/yellowcong/717350389@11.com</code> 转化为 <code>/info?age=12&amp;name=yellowcon&amp;email=717350389</code><br><code>[0-9]</code>表示 <code>0-9</code> 范围<code>i</code>数字 也可以使用<code>\d+</code><br><code>+</code> 表示1个或多个<br><code>w+</code> 表示是字符串<br><code>$</code> 表示结尾<br><code>rewrite ^/info/([0-9]+)\/(\w+)\/(\w+)$ /info?age=$1&amp;name=$2&amp;email=$3 break;</code></p><h2 id="rewrite-基于url参数的location"><a href="#rewrite-基于url参数的location" class="headerlink" title="rewrite+基于url参数的location"></a>rewrite+基于url参数的location</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">case</span> 1</span></span><br><span class="line">location ~ ^/api/v4/projects/\d+/merge_requests/\d+/changes &#123;</span><br><span class="line">    proxy_hide_header X-Frame-Options;</span><br><span class="line">    proxy_hide_header Content-Security-Policy;</span><br><span class="line">    proxy_cookie_path / &quot;/; httponly; SameSite=None; secure&quot;;</span><br><span class="line">    proxy_cache off;</span><br><span class="line">    set $is_matched 0;</span><br><span class="line">    set $real_host $host;</span><br><span class="line">    set $real_proxy &quot;gitlab-workhorse&quot;;</span><br><span class="line">    if ( $query_string ~* ^(.*)real_addr=true(.*)$ )&#123;</span><br><span class="line">      set $is_matched 1;</span><br><span class="line">      set $real_proxy &quot;xx-yy-dd.test.com&quot;;</span><br><span class="line">      set $real_host &quot;xx-yy-dd.test.com&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    proxy_set_header Host $proxy_host;</span><br><span class="line">    if ( $is_matched = 0 ) &#123;</span><br><span class="line">      rewrite ^/api/v4/projects/(.*)/changes$ /api/v2/projects/$1/changesV2 break;</span><br><span class="line">      proxy_pass http://xx-yy-dd.test.com;</span><br><span class="line">    &#125;</span><br><span class="line">    proxy_pass  http://gitlab-workhorse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">case</span> 2</span></span><br><span class="line">upstream dynamic_cn &#123;</span><br><span class="line">  server localhost:8088   weight=5;</span><br><span class="line">  server localhost:8087   weight=10;</span><br><span class="line">&#125;</span><br><span class="line">upstream dynamic_jp &#123;</span><br><span class="line">  server localhost:8086   weight=10;</span><br><span class="line">  server localhost:8085   weight=10;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">  listen 8089;</span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_pass http://dynamic_cn;</span><br><span class="line">  &#125;</span><br><span class="line">  location /hello &#123;</span><br><span class="line">    if ( $query_string ~* &quot;world=cn&quot; ) &#123;</span><br><span class="line">      proxy_pass http://dynamic_cn;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( $query_string ~* &quot;world=jp&quot; ) &#123;</span><br><span class="line">      proxy_pass http://dynamic_jp;</span><br><span class="line">    &#125;</span><br><span class="line">    proxy_pass http://dynamic_cn;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://HQ1363.github.io/categories/Nginx/">Nginx</category>
      
      
      <category domain="http://HQ1363.github.io/tags/nginx/">nginx</category>
      
      
      <comments>http://hq1363.github.io/2023/06/24/nginx/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>CI缓存加速实践</title>
      <link>http://hq1363.github.io/2023/06/18/build_cache/</link>
      <guid>http://hq1363.github.io/2023/06/18/build_cache/</guid>
      <pubDate>Sun, 18 Jun 2023 10:36:50 GMT</pubDate>
      
      <description>像Java/Go/Node/Python构建都是需要下载依赖的，如何加速构建，减少研发CICD的等待时间显得尤为重要.</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="Java-缓存"><a href="#Java-缓存" class="headerlink" title="Java 缓存"></a>Java 缓存</h2><blockquote><p>我们知道Java的缓存配置，对于Maven构建，是由settings文件指定的，一般是全局共用的本地缓存，当然我们也可以在执行mvn命令的时候，指定<code>-s</code>参数来设置settings文件，具体的配置项如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;localRepository&gt;<span class="regexp">/root/</span>.m2/repository&lt;/localRepository&gt;</span><br></pre></td></tr></table></figure><p>目前实践下来的缓存思路是按仓库来隔离每一个缓存，这么做的原因是：我们经常遇到不同仓库/应用之间的依赖相互影响，导致经常性出现缓存脏了的构建问题，处理起来很头疼.</p><h2 id="Go-缓存"><a href="#Go-缓存" class="headerlink" title="Go 缓存"></a>Go 缓存</h2><p>只缓存<code>GOCACHE</code>和<code>GOMODCACHE</code>目录，同时按仓库级别做隔离.</p><h2 id="Node-缓存"><a href="#Node-缓存" class="headerlink" title="Node 缓存"></a>Node 缓存</h2><p>缓存<code>NPM_CONFIG_CACHE</code>和<code>YARN_CACHE_FOLDER</code>目录，其次就是<code>node_modules</code>目录了，按仓库做隔离，然后动态挂载到对应构建仓库的<code>node_modules</code>目录上. </p><h3 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h3><ul><li>node仓库未按仓库做隔离，导致出现奇奇怪怪的缓存问题</li><li>使用软链的方式做仓库隔离，构建失败，没有用</li><li>使用cp/mv的方式做仓库隔离，磁盘IO非常慢，小文件又众多，跨磁盘mv/cp，简直是噩梦</li><li>使用mount的方式，挂载进去，又提示权限问题（内部系统不允许直接mount命令操作，允许的话，此方案可行）</li><li>基于k8s的磁盘挂载方式，实现动态挂载</li><li>清理node/go/java等缓存目录，简直是噩梦，速度非常非常慢，建议mv或者格式化操作</li></ul>]]></content:encoded>
      
      
      <category domain="http://HQ1363.github.io/categories/cache/">cache</category>
      
      
      <category domain="http://HQ1363.github.io/tags/cicd/">cicd</category>
      
      <category domain="http://HQ1363.github.io/tags/cache/">cache</category>
      
      
      <comments>http://hq1363.github.io/2023/06/18/build_cache/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>常用SQL指南</title>
      <link>http://hq1363.github.io/2023/06/18/sql/</link>
      <guid>http://hq1363.github.io/2023/06/18/sql/</guid>
      <pubDate>Sun, 18 Jun 2023 06:36:50 GMT</pubDate>
      
      <description>日常开发工作中，经常需要和SQL打交道，好的SQL姿势可以事半功倍.</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="多行合成一行"><a href="#多行合成一行" class="headerlink" title="多行合成一行"></a>多行合成一行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select `daily_plan_id`, GROUP_CONCAT( `pp_id` SEPARATOR &#x27;,&#x27;) as pp_ids, count(1) FROM `table_a` GROUP BY `daily_plan_id`;</span><br><span class="line"></span><br><span class="line">select group_concat(id) from table_a where repo in (&#x27;xxxx&#x27;, &#x27;yyyy&#x27;) and type = &#x27;push&#x27; and enabled = 1;</span><br></pre></td></tr></table></figure><h3 id="多列合成一列"><a href="#多列合成一列" class="headerlink" title="多列合成一列"></a>多列合成一列</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">select</span><br><span class="line">  concat_ws(&#x27;#&#x27;, name, id, git_id, `git_namespace`)</span><br><span class="line">FROM</span><br><span class="line">  `table_a`</span><br><span class="line">where</span><br><span class="line">  name in (</span><br><span class="line">    &#x27;xxxx&#x27;,</span><br><span class="line">    &#x27;yyyy&#x27;,</span><br><span class="line">    &#x27;zzzz&#x27;</span><br><span class="line">  );</span><br></pre></td></tr></table></figure><h3 id="Case-When语句"><a href="#Case-When语句" class="headerlink" title="Case When语句"></a>Case When语句</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">case</span> 1</span></span><br><span class="line">select * from (select id, created_at, plan_id, ref, commit, CASE status</span><br><span class="line">    WHEN 2 THEN &#x27;成功&#x27;</span><br><span class="line">    WHEN 3 THEN &#x27;失败&#x27;</span><br><span class="line">    ELSE &#x27;运行中&#x27;</span><br><span class="line">  END as &#x27;流水线状态&#x27;, repo, repo_id from table_a where plan_id in (223,453) and created_at BETWEEN &quot;2023-03-23 00:00:00&quot; and &quot;2023-06-10 00:00:00&quot; and (ref like &quot;release%&quot; or ref like &quot;test%&quot;) and status in (1, 2, 3)) as cp left join (select `name`, type, pipeline_id, CASE status</span><br><span class="line">    WHEN 0 THEN &#x27;等待执行&#x27;</span><br><span class="line">    WHEN 1 THEN &#x27;初始化中&#x27;</span><br><span class="line">    WHEN 2 THEN &#x27;执行中&#x27;</span><br><span class="line">    WHEN 3 THEN &#x27;成功&#x27;</span><br><span class="line">    WHEN 4 THEN &#x27;失败&#x27;</span><br><span class="line">    WHEN 5 THEN &#x27;取消&#x27;</span><br><span class="line">    ELSE &#x27;未知&#x27;</span><br><span class="line">  END as &#x27;任务状态&#x27; from table_b where type = &#x27;build&#x27;) as cj on cp.id = cj.pipeline_id;</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">case</span> 2</span></span><br><span class="line">select bus, sum(num) from (</span><br><span class="line">    select case</span><br><span class="line">        when belong_id in (12) then &#x27;xxx&#x27;</span><br><span class="line">        when belong_id in (44,213) then &#x27;vvv&#x27;</span><br><span class="line">        else &#x27;未知&#x27;</span><br><span class="line">        end as bus, count(repo) as num from table_a where repo in (</span><br><span class="line">        &#x27;xxxx/yyyy&#x27;, &#x27;yyyy/zzzz&#x27;</span><br><span class="line">        ) GROUP BY belong_id) as bn GROUP BY bn.bus;</span><br></pre></td></tr></table></figure><h3 id="IF-语句"><a href="#IF-语句" class="headerlink" title="IF 语句"></a>IF 语句</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">case</span> 1</span></span><br><span class="line">SELECT</span><br><span class="line">  project_name,</span><br><span class="line">  repo,</span><br><span class="line">  env_name,</span><br><span class="line">  IF (json_extract(setting, &#x27;$.enabled&#x27;) = true, &#x27;开启&#x27;, &#x27;关闭&#x27;)</span><br><span class="line">FROM</span><br><span class="line">  `table_a`</span><br><span class="line">where</span><br><span class="line">  repo in (&#x27;xxxx&#x27;, &#x27;yyyy&#x27;);</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">case</span> 2</span></span><br><span class="line">SELECT if(id in(</span><br><span class="line">  select distinct(`table_b`.`project_id`)  from `table_b`</span><br><span class="line">    where `table_b`.`category`= &#x27;set&#x27;), &#x27;使用&#x27;, &#x27;不使用&#x27;)  as &#x27;状态&#x27;,</span><br><span class="line">       count(1)  as &#x27;数量&#x27;</span><br><span class="line">  from table_c;</span><br></pre></td></tr></table></figure><h3 id="中文乱码问题解决"><a href="#中文乱码问题解决" class="headerlink" title="中文乱码问题解决"></a>中文乱码问题解决</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">show variables like&#x27;%char%&#x27;;  # 查看</span><br><span class="line">set character_set_results=utf8;</span><br><span class="line">set character_set_client=utf8;</span><br><span class="line">set character_set_connection=utf8;</span><br><span class="line">set character_set_database=utf8;</span><br><span class="line">set character_set_results=utf8;</span><br></pre></td></tr></table></figure><h3 id="JSON字段处理"><a href="#JSON字段处理" class="headerlink" title="JSON字段处理"></a>JSON字段处理</h3><p>JSON对象</p><ul><li>使用对象操作的方法进行查询：字段-&gt;’$.json属性’   </li><li>使用函数进行查询：json_extract(字段, ‘$.json属性’)   </li><li>获取JSON数组/对象长度：JSON_LENGTH()</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查询面料不为空的商品</span></span><br><span class="line">select * from test where desc_attr-&gt;&#x27;$.material&#x27; is not null;</span><br><span class="line">select * from test where JSON_EXTRACT(desc_attr, &#x27;$.material&#x27;) is not null;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询面料为纯棉的商品</span></span><br><span class="line">select * from test where desc_attr-&gt;&#x27;$.material&#x27;=&#x27;纯棉&#x27;;</span><br><span class="line">select * from test where JSON_EXTRACT(desc_attr, &#x27;$.material&#x27;)=&#x27;纯棉&#x27;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询标签数量大于2的商品</span></span><br><span class="line">select * from test where JSON_LENGTH(desc_attr-&gt;&#x27;$.tag&#x27;)&gt;2;</span><br></pre></td></tr></table></figure><p>JSON数组</p><ul><li>对象操作方式查询：字段-&gt;’$[0].属性’   </li><li>使用函数查询：JSON_CONTAINS(字段,JSON_OBJECT(‘json属性’, ‘内容’))   </li><li>获取JSON数组/对象长度：JSON_LENGTH()   </li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查询描述属性不为空的商品</span></span><br><span class="line">select * from test2 where JSON_LENGTH(desc_attrs) &gt; 0;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询第1项存在颜色属性的商品</span></span><br><span class="line">select * from test2 where desc_attrs-&gt;&#x27;$[0].color&#x27; is not null;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询任意项存在链接属性的商品</span></span><br><span class="line">select * from test2 where desc_attrs-&gt;&#x27;$[*].link&#x27; is not null;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询任意项存在链接等于xxx属性的商品</span></span><br><span class="line">select * from test2 where JSON_CONTAINS(desc_attrs,JSON_OBJECT(&#x27;link&#x27;, &#x27;xxx&#x27;));</span><br></pre></td></tr></table></figure><p>更多案例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">select * FROM table_a where JSON_TYPE(`extra_info`) = &#x27;NULL&#x27; limit 10;  # json_length(table_a.reason) = 0;</span><br><span class="line"><span class="meta">#</span><span class="bash"> json为对象时，查询姿势一</span></span><br><span class="line">select * from users where json_extract(address, &#x27;$.province&#x27;) = &quot;河北省&quot;;</span><br><span class="line"><span class="meta">#</span><span class="bash"> json为对象时，查询姿势二</span></span><br><span class="line">select * from users where address -&gt; &#x27;$.province&#x27; = &quot;河北省&quot;;</span><br><span class="line"><span class="meta">#</span><span class="bash"> json为数组时，查询姿势</span></span><br><span class="line">select * from users where address -&gt; &#x27;$[0]&#x27;= &quot;家&quot;;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据json对象里的属性个数进行查询</span></span><br><span class="line">select * from users where json_length(address) = 2;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询JSON数组里面对象属性任意项存在指定属性的数据</span></span><br><span class="line">select * from users where address-&gt;&#x27;$[*].city&#x27; is not null;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询JSON对象存在指定属性的数据</span></span><br><span class="line">select * from users where address-&gt;&#x27;$.tags&#x27; is not null;</span><br></pre></td></tr></table></figure><h3 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(*) from table_a inner join table_b on table_a.id = table_b.color_id where table_a.version = &#x27;527&#x27; and table_a.name not REGEXP &#x27;-[0-9]&#123;3&#125;-[0-9]+-[0-9]+$&#x27; order by color_id desc;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="http://HQ1363.github.io/categories/mysql/">mysql</category>
      
      
      <category domain="http://HQ1363.github.io/tags/mysql/">mysql</category>
      
      
      <comments>http://hq1363.github.io/2023/06/18/sql/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>pb应知应会</title>
      <link>http://hq1363.github.io/2022/01/03/pb/</link>
      <guid>http://hq1363.github.io/2022/01/03/pb/</guid>
      <pubDate>Mon, 03 Jan 2022 07:21:49 GMT</pubDate>
      
      <description>pb作为grpc的IDL语言，其自身具有极大的优点，但也存在一些使用上的问题；本文将介绍pb的规范、管理方式、以及优点和缺点。</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="pb简介"><a href="#pb简介" class="headerlink" title="pb简介"></a>pb简介</h2><blockquote><p>Protobuf是Protocol Buffers的简称，它是Google公司开发的一种数据描述语言，并于2008年对外开源。Protobuf刚开源时的定位类似于XML、JSON等数据描述语言，通过附带工具生成代码并实现将结构化数据序列化的功能。</p></blockquote><p>说的好抽象啊，我们来具象化一下：</p><blockquote><p>写过<code>thrift</code>的朋友，可能立马反应过来了，这东西也是用来定义消息以及消息是如何通信的嘛。都是为RPC服务，<u>我们知道RPC的作用，就是让远程过程调用，看起来像是本地调用一样；但实际上，是请求远端的服务，既然是请求远端的服务，我们肯定要知道对方的<span style="color: orange">服务名(service)</span>、<span style="color: orange">方法名(func)</span>、<span style="color: orange">消息结构(message/struct)</span>吖，不然我找谁去请求，我怎么去解析数据</u>。proto文件就是干这么一件事，所以proto也是一种描述性语言嘛。</p></blockquote><h3 id="pb的好处"><a href="#pb的好处" class="headerlink" title="pb的好处"></a>pb的好处</h3><blockquote><p><code>Protocol Buffers</code>是一种轻便高效的结构化数据存储格式，可以用于结构化数据的序列化，很适合做数据存储或 RPC 数据交换格式。它可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。</p></blockquote><p>听起来，设计rpc的通信协议，好像很简单，也没什么嘛，不就是简单的协议（语法、语义、时序）定义嘛！！！其实不然，这其中，需要考虑的问题很多，比如：<u style="color: orange">数据发送方如何序列化传输数据</u>、<u style="color: orange">数据接受方需要如何接收并反序列化数据</u>、<u style="color: orange">数据的传输效率如何提高</u>、<u style="color: orange">各种语言如何与pb语义对应上</u>等等。</p><h3 id="pb编码方式"><a href="#pb编码方式" class="headerlink" title="pb编码方式"></a>pb编码方式</h3><blockquote><p>在XML或JSON等数据描述语言中，一般通过成员的名字来绑定对应的数据。但是Protobuf编码却是通过成员的唯一编号来绑定对应的数据，因此Protobuf编码后数据的体积会比较小，但是也非常不便于人类查阅。</p></blockquote><h3 id="pb的使用"><a href="#pb的使用" class="headerlink" title="pb的使用"></a>pb的使用</h3><ul><li><code>.proto</code>文件的书写</li><li>使用IDL编译器编译成对应语言的代码</li></ul><h2 id="pb书写规范"><a href="#pb书写规范" class="headerlink" title="pb书写规范"></a><a href="https://developers.google.com/protocol-buffers/docs/style">pb书写规范</a></h2><ul><li><code>pb</code>文件名为小写+下划线形式，文件后缀以<code>.proto</code>结尾</li><li>保证每行80字符左右；请使用2个空格缩进</li><li>除结构定义之外的语句均以分号结尾</li><li>包名必须小写, 并应与目录层次结构相对应. 例如: test/pb/api.proto 包名应该为test.pb</li><li><code>message</code>结构体命名采用驼峰命名方式，字段命名采用小写字母加下划线分隔方式</li><li><code>enums</code>类型名采用驼峰命名方式，字段命名采用大写字母加下划线分隔方式</li><li><code>service</code>与<code>rpc</code>方法名统一采用驼峰式命名</li></ul><h3 id="案例说明"><a href="#案例说明" class="headerlink" title="案例说明"></a>案例说明</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定proto的版本，默认proto2；proto3对语言进行了提炼简化，所有成员均采用类似Go语言中的零值初始化（不再支持自定义默认值）</span></span><br><span class="line"><span class="comment">// 因此消息成员也不再需要支持required特性。</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义包名(import path)，防止message重名</span></span><br><span class="line"><span class="keyword">package</span> main;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入外部pb</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;google/protobuf/timestamp.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加可选项</span></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;github.com/protocolbuffers/protobuf/examples/go/tutorialpb&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PersonType</span> </span>&#123;</span><br><span class="line">  WHITE = <span class="number">0</span>;</span><br><span class="line">  BLACK = <span class="number">1</span>;</span><br><span class="line">  YELLOW = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  PersonType type = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// Unique ID number for this person.</span></span><br><span class="line">  <span class="built_in">int32</span> id = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">string</span> email = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">PhoneType</span> </span>&#123;</span><br><span class="line">    MOBILE = <span class="number">0</span>;</span><br><span class="line">    HOME = <span class="number">1</span>;</span><br><span class="line">    WORK = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">message</span> <span class="title">PhoneNumber</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> number = <span class="number">1</span> [(gogoproto.jsontag) = <span class="string">&quot;number&quot;</span>, json_name = <span class="string">&quot;number&quot;</span> ];</span><br><span class="line">    PhoneType type = <span class="number">2</span> [(gogoproto.jsontag) = <span class="string">&quot;type&quot;</span>, json_name = <span class="string">&quot;type&quot;</span> ];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">repeated</span> PhoneNumber phones = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">  google.protobuf.Timestamp last_updated = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义message（可定义多个）</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">EntranceReq</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义字段： type fieldName = fieldNumber; </span></span><br><span class="line">  <span class="built_in">string</span> query = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">int32</span> result_per_page = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// EntranceResp 入口返回结果</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">EntranceResp</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 图标</span></span><br><span class="line">    <span class="built_in">string</span> icon = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 名称</span></span><br><span class="line">    <span class="built_in">string</span> name = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义服务和方法</span></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 活动入口</span></span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> TestEntrance (EntranceReq) <span class="keyword">returns</span> (EntranceResp)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="划重点"><a href="#划重点" class="headerlink" title="划重点"></a>划重点</h3><h4 id="字段的fieldNumber"><a href="#字段的fieldNumber" class="headerlink" title="字段的fieldNumber"></a>字段的<code>fieldNumber</code></h4><blockquote><p>这个并不是<code>fieldName</code>的值，只是一个标号（<code>tag</code>），意味着：往后见到<code>fieldNumber</code>就代表是<code>fieldName</code>；换句话说，字段叫啥名在protobuf中并不重要, 因为在传输的时候，二进制数据流里用的是<code>fieldNumber</code>而不是<code>fieldName</code>；所以<code>fieldNumber</code>一旦被使用, 终生这个编号都不要改变，否则很可能引发线上故障，这也是为什么我们说pb字段的<code>fieldNumber</code>只能追加，不能修改，或者插入的原因。<br><code>fieldNumber</code>的取值范围是1~2^29-1. 而常用的<code>fieldNumber</code>范围是: 1-15(只用1个byte编码),  16-2047(采用2个byte编码). 所以为了节省编码后的长度, 经常使用的一些字段名(如:name, id等), 分配1-15的<code>fieldNumber</code>.</p></blockquote><h4 id="字段的定义"><a href="#字段的定义" class="headerlink" title="字段的定义"></a>字段的定义</h4><ul><li>singular单数字段: protobuf的默认字段规则, 就是说这个字段只能出现0或者1次.</li><li>repeated重复字段: 代表该字段是一个数组或者list. 数组里面可以有任意数量的元素. 如果有多个元素, 元素的顺序会被保留.</li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Shop</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int32</span> id = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">string</span> name = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// 商店会有多个服务员</span></span><br><span class="line">  <span class="keyword">repeated</span> <span class="built_in">string</span> staff = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="保留字段"><a href="#保留字段" class="headerlink" title="保留字段"></a>保留字段</h4><blockquote><p>保留字段的意思就是, 这些字段保留下来, 后续在protobuf中,不能再次使用了.(即: 防止字段名一样, 但是字段含义不同)</p></blockquote><p>案例说明</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">reserved <span class="number">2</span>, <span class="number">3</span> to <span class="number">7</span>; <span class="comment">// 保留这几个fieldNumber</span></span><br><span class="line">    reserved <span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>; <span class="comment">// 保留这几个字段名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子解释下为啥要保留字段</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一开始的需求, UserInfo绑定的是微信的账号和密码</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line"><span class="built_in">int32</span> Id = <span class="number">1</span>;</span><br><span class="line">    stirng name = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> wechat_account = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">string</span> wechat_pwd = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在需求变了,要求用户信息绑定QQ账号密码</span></span><br><span class="line"><span class="comment">// 此时我删除了 wechat_account wechat_pwd两个字段, 并添加QQ_account, QQ_pwd</span></span><br><span class="line"><span class="comment">// 同时, 之前分配给wechat_account和wechat_pwd的fieldNumber 3 4, 又再一次分配给了 QQ_account和QQ_pwd.</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line"><span class="built_in">int32</span> Id = <span class="number">1</span>;</span><br><span class="line">    stirng name = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> QQ_account = <span class="number">3</span>;</span><br><span class="line">    <span class="built_in">string</span> QQ_pwd = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 想想会有什么问题?</span></span><br><span class="line"><span class="comment">// 别想了,我直接说了, 假如server端修改了protobuf的定义,但是client端还没有更新.</span></span><br><span class="line"><span class="comment">// 此时, 客户端传给server微信的账号/密码, 服务端作为QQ的账号密码去验证,肯定是错的.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以呢? 所以修改(如删掉)的字段和对应的fieldNumber都应该保留, 后续都不能在使用了.</span></span><br></pre></td></tr></table></figure><h4 id="enum-枚举类型"><a href="#enum-枚举类型" class="headerlink" title="enum 枚举类型"></a><code>enum</code> 枚举类型</h4><blockquote><p>枚举可以定义在message里面,也可以定义在外面(便于复用)；在另一个message类型中,可以通过UserInfo.Gender, 使用枚举类型. reserved同样也可以适用于枚举类型.</p></blockquote><p>案例说明</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Gender gender = <span class="number">1</span>; <span class="comment">// 使用Gender枚举类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定义枚举类型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Gender</span> </span>&#123;</span><br><span class="line">    FEMAIL = <span class="number">0</span>; <span class="comment">// 必须从0开始</span></span><br><span class="line">        MAIL = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="message类型"><a href="#message类型" class="headerlink" title="message类型"></a><code>message</code>类型</h4><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="built_in">int32</span> id = <span class="number">1</span>; </span><br><span class="line">    <span class="built_in">string</span> name = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    Date birthday = <span class="number">3</span>; <span class="comment">// 使用message类型作为字段的type</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义消息类型Date:生日</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Date</span> </span>&#123;</span><br><span class="line">    <span class="built_in">int32</span> year = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">int32</span> mounth = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">int32</span> day = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Tips：一般来说,不相关的消息, 每个message,创建一个proto文件. 如果需要用到其他.proto文件中定义的message, 要通过import进行引入. 编译器会在–proto_path参数指定的路径下寻找相应的需要导入的proto文件. 不写默认在当前目录寻找.</p><h4 id="package包名"><a href="#package包名" class="headerlink" title="package包名"></a><code>package</code>包名</h4><blockquote><p>给一个.proto文件指定package, 是为了避免和其他的.proto文件的message名称冲突.</p></blockquote><p>案例说明</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bar.proto</span></span><br><span class="line"><span class="keyword">package</span> foo.bar;</span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Open</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>后面可以使用该.proto文件的包名去使用message Open</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.proto</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;bar.proto&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  foo.bar.Open open = <span class="number">1</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当被IDL编译器翻译成GO语言后, Go代码的包名, 默认就是.proto文件的pacakge名称, 除非在.proto文件中显示的用go_pacakge指定IDL编译后的Go文件的import path.</p><h4 id="import的搜寻路径是？"><a href="#import的搜寻路径是？" class="headerlink" title="import的搜寻路径是？"></a>import的搜寻路径是？</h4><blockquote><p>搜寻路径由protoc -I或者protoc –proto_path指定. 所以, import 要和 protoc -I/–proto_path 命令配合好.</p></blockquote><h3 id="踩坑笔记"><a href="#踩坑笔记" class="headerlink" title="踩坑笔记"></a>踩坑笔记</h3><ul><li>任何地方的命名，都不要使用关键字，会出问题</li><li>java_package中，包含关键字（如：public / interface）</li><li>pb文件中，混入奇怪的不可打印字符，或者是混入无用的、语法不对的字符</li><li>enum和message名字不一样就好</li><li>message的名字不要和文件名一样，小心踩坑</li></ul><h2 id="pb管理办法"><a href="#pb管理办法" class="headerlink" title="pb管理办法"></a>pb管理办法</h2><blockquote><p>pb是好用，可是如何优雅的管理起来，是个头疼的问题；微服务化后，多人协作开发上，就很容易出问题。不禁引人发问：proto这个IDL的代码到底应该放在哪里，该怎么管理？这里简单讨论下</p></blockquote><p>能够想到的几种方式如下：</p><ul><li>代码仓库</li><li>独立仓库</li><li>集中仓库</li><li>镜像仓库</li><li>组合方式</li></ul><h3 id="代码仓库"><a href="#代码仓库" class="headerlink" title="代码仓库"></a>代码仓库</h3><p>直接将项目所依赖的所有proto文件都存放在项目的<code>proto/</code>目录下，不经过开发工具的自动拉取和发布：</p><div>  <img data-src="manage1.png" width="300px" alt="代码仓库"></div><ul><li>优点<ul><li>项目所有依赖的 Proto 都存储在代码仓库下，因此不涉及个人开仓库权限的问题。</li><li>多 Proto 的切换开销减少，因为都在代码仓库下，不需要看这看那。</li></ul></li><li>缺点<ul><li>项目所有依赖的 Proto 都存储在代码仓库下，因此所有依赖 Proto 都需要人工的向其它业务组 “要” 来，再放到 proto/ 目录下，人工介入极度麻烦。</li><li>Proto 升级和变更，经常要重复第一步，沟通成本高。</li></ul></li></ul><h3 id="独立仓库"><a href="#独立仓库" class="headerlink" title="独立仓库"></a>独立仓库</h3><blockquote><p>独立仓库存储是我们最早采取的方式，也就是每个服务对应配套一个 Proto 仓库</p></blockquote><div>  <img data-src="manage2.png" width="400px" alt="独立仓库"></div><p>这个方案的好处就是可以独立管理所有 Proto 仓库，并且权限划分清晰。但最大的优点也是最大的缺点。因为一个服务会依赖多个 Proto 仓库，并且存在跨业务组调用的情况</p><div>  <img data-src="manage3.png" width="400px" alt="独立仓库"></div><p>如上图所示，svc-user 服务分别依赖了三块 Proto 仓库，分别是自己组的、业务组 A、业务组 B 总共的 6 个 Proto 仓库。</p><ul><li>优点<ul><li>使得安全性较高（但 IDL 本身没有太多的秘密）。</li><li>按需拉取，不需要关注其余的服务 Proto。</li></ul></li><li>缺点<ul><li>假设你是一个新入职的开发人员，那么你就需要找不同的业务组申请不同的仓库权限，非常麻烦。如果没有批量赋权工具，也没有管理者权限，那么就需要一个个赋权，非常麻烦。</li><li>在运行服务的时候，你需要将所有相关联的 Proto 仓库拉取下来，如果没有工具做半自动化的支持，麻烦程度无法忍受。</li></ul></li></ul><h3 id="集中仓库"><a href="#集中仓库" class="headerlink" title="集中仓库"></a>集中仓库</h3><blockquote><p>集中仓库也是一些公司考虑的方式之一，是按公司或大事业部的维度进行 Proto 代码的存储。这样子只需要拉取一个仓库，就可以获取到所有所需的IDL.</p></blockquote><div>  <img data-src="manage4.png" width="400px" alt="集中仓库"></div><ul><li>优点<ul><li>只需要拉取一次Proto仓库就可以轻松把一个服务所需的 IDL 集齐。</li><li>仓库权限管理的复杂度下降。</li></ul></li><li>缺点<ul><li>安全性下降，因为其它业务组的IDL也全都 “泄露” 了。</li><li>非按需拉取，在查看原始文件时，需要关注一些多余的。</li></ul></li></ul><h3 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h3><blockquote><p>自己服务的 Proto 文件存放在代码仓库的 proto 文件中，在本次 feature 提交或发布后，自动同步到镜像仓库去。你所依赖的其他服务 Proto 则直接通过读取集中的镜像仓库的方式获取.</p></blockquote><div>  <img data-src="manage5.png" width="500px" alt="镜像仓库"></div><p>这样子的话，通过开发工具的配合，开发人员在开发时就只需要关注自己项目的 Proto 就好了。集中的镜像仓库主要用于构建和部署，大幅度降低了多Proto的关注和切换开销。</p><h3 id="组合方式"><a href="#组合方式" class="headerlink" title="组合方式"></a>组合方式</h3><blockquote><p>单一的方式，或多或少的都存在一些问题，如果采用组合的方式，可以最大程度地发挥作用。例如：独立仓库+集中仓库，对于公共的、需要暴露出去的部分放到集中仓库，不需要暴露出去的就放到独立仓库（例如：部门内部的，可以放到独立仓库，需要跨部门的，可以放到集中仓库），可以一定程度上降低安全性问题。</p></blockquote><p>实际工作中，我们不仅需要考虑proto文件的管理，还需要管理proto编译产物的管理，而这个过程，需要考虑到区分版本的问题，因为测试和上线是两个不同的阶段，不能让测试的版本，被用到了线上。</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://juejin.cn/post/6865126893063471112">Protobuf入门（大白话版）</a></li><li><a href="https://mp.weixin.qq.com/s/cBXZjg_R8MLFDJyFtpjVVQ">真是头疼，Proto 代码到底放哪里？</a></li></ul>]]></content:encoded>
      
      
      <category domain="http://HQ1363.github.io/categories/go/">go</category>
      
      <category domain="http://HQ1363.github.io/categories/go/grpc/">grpc</category>
      
      <category domain="http://HQ1363.github.io/categories/go/grpc/pb/">pb</category>
      
      
      <category domain="http://HQ1363.github.io/tags/pb/">pb</category>
      
      
      <comments>http://hq1363.github.io/2022/01/03/pb/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>前端常见面试题</title>
      <link>http://hq1363.github.io/2021/09/27/frontend-interview/</link>
      <guid>http://hq1363.github.io/2021/09/27/frontend-interview/</guid>
      <pubDate>Mon, 27 Sep 2021 04:01:40 GMT</pubDate>
      
      <description>最近公司在招人，面了挺多人，这里总结下招人的心得和常见问题.</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="前端工程师"><a href="#前端工程师" class="headerlink" title="前端工程师"></a>前端工程师</h2><h3 id="技能要求"><a href="#技能要求" class="headerlink" title="技能要求"></a>技能要求</h3><ul><li>熟悉<code>Vue</code>/<code>React</code>其中一种</li><li>熟悉<code>Webpack</code>配置</li><li>精通<code>Html5</code>、<code>Javascript</code>，熟练掌握主流<code>mvc</code>、<code>mvvm</code>前端框架</li><li>具备良好的数据结构和算法知识</li><li>对前端有浓厚的兴趣，具有快速学习能力，乐于探索，并有良好的编码习惯</li></ul><h3 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h3><ul><li>vue指令，v-show指令和v-if指令的区别是什么？</li><li>data为什么是一个函数而不是对象</li><li>vue常用指令<ul><li>v-model 多用于表单元素实现双向数据绑定（同angular中的ng-model）</li><li>v-bind 动态绑定 作用： 及时对页面的数据进行更改</li><li>v-on:click 给标签绑定函数，可以缩写为@，例如绑定一个点击函数 函数必须写在methods里面</li><li>v-for 格式： v-for=”字段名 in(of) 数组json” 循环数组或json(同angular中的ng-repeat)</li><li>v-show 显示内容 （同angular中的ng-show）</li><li>v-hide 隐藏内容（同angular中的ng-hide）</li><li>v-if 显示与隐藏 （dom元素的删除添加 同angular中的ng-if 默认值为false）</li><li>v-else-if 必须和v-if连用</li><li>v-else 必须和v-if连用 不能单独使用 否则报错 模板编译错误</li><li>v-text 解析文本</li><li>v-html 解析html标签</li><li>v-bind:class 三种绑定方法 1、对象型 ‘{red:isred}’ 2、三元型 ‘isred?”red”:”blue”‘ 3、数组型 ‘[{red:”isred”},{blue:”isblue”}]’</li><li>v-once 进入页面时 只渲染一次 不在进行渲染</li><li>v-cloak 防止闪烁</li><li>v-pre 把标签内部的元素原位输出</li></ul></li><li>组件传值方式有哪些，父子之间的数据如果需要相互访问，可以有哪些方式？<ul><li>父传子：子组件通过props[‘xx’] 来接收父组件传递的属性 xx 的值</li><li>子传父：子组件通过 this.$emit(‘fnName’,value) 来传递,父组件通过接收 fnName 事件方法来接收回调</li><li>使用Vuex</li></ul></li><li>vuex的核心概念<ul><li>state =&gt; 基本数据</li><li>getters =&gt; 从基本数据派生的数据</li><li>mutations =&gt; 修改数据，同步</li><li>actions =&gt; 修改数据，异步 (Action 提交的是 mutation，而不是直接变更状态)</li><li>modules =&gt; 模块化Vuex</li></ul></li><li>目前的前端开发架子，是？<ul><li>路由是用哪个库？</li><li>UI组件是哪个？</li><li>css解析是哪个？</li><li>ajax异步接口请求，用的是哪个库？</li><li>图表类库，都用过哪些</li><li>全局状态维护，用的是哪个库？</li></ul></li><li>css如何只在当前组件起作用？</li><li>vue实现数据双向绑定的原理</li><li>vue的生命周期函数，都有哪些？</li><li>css的选择器，都有哪些？</li><li>cookie和session的区别</li><li>localStorage和SessionStorage的区别</li><li>get和post的区别</li><li>说一说http的缓存</li><li>常见状态码的含义和产生原因</li><li>从浏览器输入url后都经历了什么</li></ul>]]></content:encoded>
      
      
      <category domain="http://HQ1363.github.io/categories/vue/">vue</category>
      
      <category domain="http://HQ1363.github.io/categories/vue/javascript/">javascript</category>
      
      <category domain="http://HQ1363.github.io/categories/vue/javascript/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <category domain="http://HQ1363.github.io/tags/vue/">vue</category>
      
      <category domain="http://HQ1363.github.io/tags/javascript/">javascript</category>
      
      <category domain="http://HQ1363.github.io/tags/%E9%9D%A2%E8%AF%95/">面试</category>
      
      
      <comments>http://hq1363.github.io/2021/09/27/frontend-interview/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>学习GPRC，这篇就够了</title>
      <link>http://hq1363.github.io/2021/09/14/grpc-intro/</link>
      <guid>http://hq1363.github.io/2021/09/14/grpc-intro/</guid>
      <pubDate>Tue, 14 Sep 2021 02:25:09 GMT</pubDate>
      
      <description>gRPC 是一个高性能、开源和通用的 RPC 框架，面向移动和 HTTP/2 设计。目前提供 C、Java 和 Go 语言版本，分别是：grpc, grpc-java, grpc-go</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="GRPC简介"><a href="#GRPC简介" class="headerlink" title="GRPC简介"></a>GRPC简介</h2>]]></content:encoded>
      
      
      <category domain="http://HQ1363.github.io/categories/grpc/">grpc</category>
      
      
      <category domain="http://HQ1363.github.io/tags/go/">go</category>
      
      <category domain="http://HQ1363.github.io/tags/grpc/">grpc</category>
      
      
      <comments>http://hq1363.github.io/2021/09/14/grpc-intro/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>gorm血泪史</title>
      <link>http://hq1363.github.io/2021/09/10/go-gorm-blood-tears/</link>
      <guid>http://hq1363.github.io/2021/09/10/go-gorm-blood-tears/</guid>
      <pubDate>Fri, 10 Sep 2021 04:03:49 GMT</pubDate>
      
      <description>如果你用过gorm，只希望各位大佬不要踩这些坑，每一个都是血和泪的教训。</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="Rows没有Close"><a href="#Rows没有Close" class="headerlink" title="Rows没有Close"></a>Rows没有Close</h3><blockquote><p><strong>上下文</strong>：有个实习生，写了一个需求，结果for循环到第十次的时候，一直卡死，没有任何响应，最终请求超时；不仅如此，后续的接口请求，都是没有处理的，整个程序仿佛处于假死状态。这让当时的我感到十分诧异，我的第一个感觉是存在死循环，为了证实猜想，开始对整个for循环体做单步调试，结果发现，并不存在死循环，程序卡在某个SQL执行处；于是我就想，难道是慢SQL，导致一直从DB拿不到返回结果，但很快我就排除了这种可能性，毕竟问题是发生第十次，而不是第一次；在问题稳定复现后，我开始总结规律，问题复现一定是在for循环执行到第十次的时候，就有这么巧吗，回回都是第十次，也太邪乎了。</p></blockquote><p><u>针对上述的问题，毫无疑问，肯定是出了DB上的问题，然后又是第十次稳定复现，我开始怀疑DB连接的问题，比如连接被吃满，不够用</u>；于是乎，我开始检查程序连接DB的配置，发现active激活连接数，配置的最大值就是10个，这不刚好就是10嘛，<span style="color:orange">这不是巧了嘛！这不是巧了嘛！</span>那就调大嘛，结果然并软，反而换了一个报错<u>（MySQL error code 1135 (ER_CANT_CREATE_THREAD): Can’t create a new thread (errno %d); if you are not out of available memory, you can consult the manual for a possible OS-dependent bug）</u>，这又是什么鬼啊，why！！！<br><img data-src="question.jpeg">哼，不陪你玩了，哪儿凉快哪儿呆着去吧；哈哈，回到正题，不然要被你们打😄</p><p><strong style="font-size:20px;color:blue">难道不是连接的问题吗，我开始更换思路</strong>；我的SQL请求到底有没有打到MySQL服务器呢，我开始求助DBA，希望帮捞下，第十次的SQL执行日志，得到的反馈是一切正常。what，不对啊；因为程序DB操作，用的是Gorm，我开始查阅官方文档，搜索github上的issue，并为找到任何有用的消息。对新出现的error信息，同向DBA老师求证后，排除了，没办法，我只能把连接配置，改回去，继续排查问题。然后一步步的检查代码，发现DB操作，<u style="color:red">少了一个释放连接的动作</u>，于是我加上，赶紧验证了一下，好在问题得到解决了。<br><img data-src="good.jpeg">我们来看看代码：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原生 SQL</span></span><br><span class="line">rows, err := db.Raw(<span class="string">&quot;select name, age, email from users where name = ?&quot;</span>, <span class="string">&quot;jinzhu&quot;</span>).Rows()</span><br><span class="line"><span class="keyword">defer</span> rows.Close()   <span class="comment">// 就是这行代码少了，导致的</span></span><br><span class="line"><span class="keyword">for</span> rows.Next() &#123;</span><br><span class="line">  rows.Scan(&amp;name, &amp;age, &amp;email)</span><br><span class="line">  <span class="comment">// 业务逻辑...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查阅资料后，大胆猜测：<u>有可能是mysql每次去查询的时候，获取一个连接，没有空闲的连接，则创建一个新的，查询完成后释放连接到连接池，以便下一个请求使用，而由于没有调用rows.Close()，导致拿了连接之后，没有再放回连接池复用；而我的连接配置最大就是10，所以在第十次执行完后，第十一次，已经无法分配新的连接去执行SQL，最终一直等待，拿不到结果。</u><a href="https://segmentfault.com/a/1190000021493463" target="_blank">感兴趣的朋友，可以看看这篇文章，基于gorm源码解释了问题原因</a>；未执行rows.Close()还可能导致内存泄漏、启动一堆的goroutine不退出等问题。</p>]]></content:encoded>
      
      
      <category domain="http://HQ1363.github.io/categories/gorm/">gorm</category>
      
      
      <category domain="http://HQ1363.github.io/tags/gorm/">gorm</category>
      
      <category domain="http://HQ1363.github.io/tags/go/">go</category>
      
      
      <comments>http://hq1363.github.io/2021/09/10/go-gorm-blood-tears/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
